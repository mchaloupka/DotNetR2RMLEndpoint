<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Slp.Evi.Storage</name>
    </assembly>
    <members>
        <member name="T:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory">
            <summary>
            Class DefaultEviQueryableStorageFactory.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.CreateQueryProcessor(Slp.Evi.Storage.Database.ISqlDatabase,TCode.r2rml4net.IR2RML)">
            <summary>
            Creates the query processor.
            </summary>
            <param name="db">The database.</param>
            <param name="mapping">The mapping.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.CreateMappingProcessor(TCode.r2rml4net.IR2RML)">
            <summary>
            Creates the mapping processor.
            </summary>
            <param name="mapping">The mapping.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.CreateSparqlBuilder">
            <summary>
            Creates the sparql algebra builder.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.CreateQueryContext(VDS.RDF.Query.SparqlQuery,Slp.Evi.Storage.Mapping.MappingProcessor,Slp.Evi.Storage.Database.ISqlDatabase,Slp.Evi.Storage.DBSchema.IDbSchemaProvider,VDS.RDF.INodeFactory)">
            <summary>
            Creates the query context.
            </summary>
            <param name="originalQuery">The original query.</param>
            <param name="mapping">The mapping.</param>
            <param name="db">The database.</param>
            <param name="schemaProvider"></param>
            <param name="nodeFactory">The node factory.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.CreateRelationalBuilder">
            <summary>
            Creates the relational builder.
            </summary>
            <returns>The relational builder.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.GetRelationalOptimizers">
            <summary>
            Gets the relational optimizers.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.DefaultEviQueryableStorageFactory.GetSparqlOptimizers">
            <summary>
            Gets the SPARQL optimizers.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Bootstrap.ISqlDbFactory">
            <summary>
            Factory for database related things
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.ISqlDbFactory.CreateSqlDb(System.String)">
            <summary>
            Creates the SQL database.
            </summary>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.ISqlDbFactory.CreateSqlQueryBuilder">
            <summary>
            Creates the SQL query builder.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory">
            <summary>
            Factory for <see cref="T:Slp.Evi.Storage.EviQueryableStorage"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.CreateQueryProcessor(Slp.Evi.Storage.Database.ISqlDatabase,TCode.r2rml4net.IR2RML)">
            <summary>
            Creates the query processor.
            </summary>
            <param name="db">The database.</param>
            <param name="mapping">The R2RML mapping.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.CreateMappingProcessor(TCode.r2rml4net.IR2RML)">
            <summary>
            Creates the mapping processor.
            </summary>
            <param name="mapping">The R2MRML mapping.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.CreateSparqlBuilder">
            <summary>
            Creates the sparql algebra builder.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.CreateQueryContext(VDS.RDF.Query.SparqlQuery,Slp.Evi.Storage.Mapping.MappingProcessor,Slp.Evi.Storage.Database.ISqlDatabase,Slp.Evi.Storage.DBSchema.IDbSchemaProvider,VDS.RDF.INodeFactory)">
            <summary>
            Creates the query context.
            </summary>
            <param name="originalQuery">The original query.</param>
            <param name="mapping">The mapping.</param>
            <param name="db">The database.</param>
            <param name="schemaProvider"></param>
            <param name="nodeFactory">The node factory.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.CreateRelationalBuilder">
            <summary>
            Creates the relational builder.
            </summary>
            <returns>RelationalBuilder.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.GetRelationalOptimizers">
            <summary>
            Gets the relational optimizers.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory.GetSparqlOptimizers">
            <summary>
            Gets the SPARQL optimizers.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult">
            <summary>
            The result of pattern matching.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult"/> class.
            </summary>
            <param name="conditions">The conditions.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult.Conditions">
            <summary>
            Gets the conditions.
            </summary>
            <value>The conditions.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult.NeverMatch">
            <summary>
            Gets a value indicating whether this instance never matches.
            </summary>
            <value><c>true</c> if this instance never matches; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.CompareResult.AlwaysMatch">
            <summary>
            Gets a value indicating whether this instance always matches.
            </summary>
            <value><c>true</c> if this instance always matches; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition">
            <summary>
            The match condition
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition"/> class from being created.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.IsAlwaysFalse">
            <summary>
            Gets a value indicating whether this instance is always false.
            </summary>
            <value><c>true</c> if this instance is always false; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.LeftPattern">
            <summary>
            Gets the left pattern.
            </summary>
            <remarks>
            Do not get this value if <see cref="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.IsAlwaysFalse"/> is <c>true</c>.
            </remarks>
            <value>The left pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.RightPattern">
            <summary>
            Gets the right pattern.
            </summary>
            <remarks>
            Do not get this value if <see cref="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.IsAlwaysFalse"/> is <c>true</c>.
            </remarks>
            <value>The right pattern.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.CreateAlwaysFalseCondition">
            <summary>
            Creates the always false condition.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition.CreateCondition(Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern,Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern)">
            <summary>
            Creates the condition.
            </summary>
            <param name="leftPattern">The left pattern.</param>
            <param name="rightPattern">The right pattern.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern">
            <summary>
            Class representing pattern in pattern matching.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern.IsIriEscaped">
            <summary>
            Gets a value indicating whether this instance is iri escaped.
            </summary>
            <value><c>true</c> if this instance is iri escaped; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern.PatternItems">
            <summary>
            Gets the pattern items.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern.#ctor(System.Boolean,System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern"/> class.
            </summary>
            <param name="isIriEscaped">if set to <c>true</c> the pattern is iri escaped.</param>
            <param name="patternItems">The pattern items.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer">
            <summary>
            Class PatternComparer.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.Compare(Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern,Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern)">
            <summary>
            Compares the specified pattern <paramref name="left"/> to the pattern <paramref name="right"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetIriEscapedPrefix(Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem[],System.Int32@,System.Int32,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Gets the IRI escaped prefix.
            </summary>
            <param name="patternItems">The pattern items.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="prefix">The prefix.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.ProcessSuffixes(System.Text.StringBuilder,System.Text.StringBuilder,System.Collections.Generic.List{Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition},System.Boolean@)">
            <summary>
            Processes the suffixes.
            </summary>
            <param name="leftSuffix">The left suffix.</param>
            <param name="rightSuffix">The right suffix.</param>
            <param name="conditions">The conditions.</param>
            <param name="performedAction">if set to <c>true</c> the method performed some action.</param>
            <returns><c>true</c> if there was a "never match" condition found.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.ProcessPrefixes(System.Text.StringBuilder,System.Text.StringBuilder,System.Collections.Generic.List{Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition},System.Boolean@)">
            <summary>
            Processes the prefixes.
            </summary>
            <param name="leftPrefix">The left prefix.</param>
            <param name="rightPrefix">The right prefix.</param>
            <param name="conditions">The conditions.</param>
            <param name="performedAction">if set to <c>true</c> the method performed some action.</param>
            <returns><c>true</c> if there was a "never match" condition found.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetRemainingPattern(System.Boolean,Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem[],System.Text.StringBuilder,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Gets the remaining pattern.
            </summary>
            <param name="isIriEscaped">Is the pattern IRI escaped.</param>
            <param name="patternItems">The pattern items.</param>
            <param name="prefix">The prefix.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetRemainingPatternItems(Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem[],System.Text.StringBuilder,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Gets the remaining pattern items.
            </summary>
            <param name="patternItems">The pattern items.</param>
            <param name="prefix">The prefix.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetAndCutSuffixEnd(System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets and cut the suffix end.
            </summary>
            <param name="suffix">The suffix.</param>
            <param name="minSharedSuffix">The shared suffix to get and cut.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetAndCutPrefixStart(System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets and cut the prefix start.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="minSharedPrefix">The shared prefix to get and cut.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetSuffix(Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem[],System.Int32,System.Int32@,System.Text.StringBuilder)">
            <summary>
            Gets the suffix.
            </summary>
            <param name="patternItems">The pattern items.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer.GetPrefix(Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem[],System.Text.StringBuilder,System.Int32@,System.Int32,System.Text.StringBuilder)">
            <summary>
            Gets the prefix.
            </summary>
            <param name="patternItems">The pattern items.</param>
            <param name="prefix">The prefix.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem">
            <summary>
            Class part of pattern in the pattern matching.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem._isColumn">
            <summary>
            Value indicating whether this instance is column.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.IsColumn">
            <summary>
            Gets a value indicating whether this instance is column.
            </summary>
            <value><c>true</c> if this instance is column; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.IsConstant">
            <summary>
            Gets a value indicating whether this instance is constant.
            </summary>
            <value><c>true</c> if this instance is constant; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem"/> class of column type.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem"/> class of constant type with
            <paramref name="text"/> as text.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.Text">
            <summary>
            Gets the assigned text (if the instance is constant)
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.RelationalColumn">
            <summary>
            Gets or sets the relational column of this pattern item.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem.FromTemplatePart(Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart)">
            <summary>
            Creates <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem"/> from the template part.
            </summary>
            <param name="templatePart">The template part.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Base.BaseSqlDb">
            <summary>
            Base database representation
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Base.BaseSqlDb._queryBuilder">
            <summary>
            The query builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.#ctor(Slp.Evi.Storage.Bootstrap.ISqlDbFactory,System.String,DatabaseSchemaReader.DataSchema.SqlType)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Base.BaseSqlDb" /> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="connectionString">The connection string.</param>
            <param name="sqlType">Type of the SQL.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.GenerateQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the query.
            </summary>
            <param name="relationalQuery">The relational model.</param>
            <param name="context">The query context.</param>
            <returns>The SQL query</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.ExecuteQuery(System.String)">
            <summary>
            Executes the query.
            </summary>
            <param name="query">The query.</param>
            <returns>The query result reader.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlDb.ConnectionString">
            <summary>
            Gets the connection string.
            </summary>
            <value>The connection string.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlDb.SqlType">
            <summary>
            Gets the type of the SQL connection.
            </summary>
            <value>The type of the SQL.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.GetTableNameUnquoted(System.String)">
            <summary>
            Gets the unquoted table name.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.GetSchemaTableName(System.String)">
            <summary>
            Gets the name of table in the schema.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlDb.GetColumnNameUnquoted(System.String)">
            <summary>
            Gets the unquoted column name.
            </summary>
            <param name="columnName">Name of the column.</param>
            <returns>System.String.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlDb.SqlTypeForString">
            <summary>
            Gets the SQL type for string.
            </summary>
            <value>The SQL type for string.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlDb.SqlTypeForInt">
            <summary>
            Gets the SQL type for int.
            </summary>
            <value>The SQL type for int.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder">
            <summary>
            The base sql query builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.GenerateQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the query.
            </summary>
            <param name="relationalQuery">The relational query.</param>
            <param name="context">The context.</param>
            <returns>The query string.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext">
            <summary>
            The context for visitor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.#ctor(System.Text.StringBuilder,Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.RelationalQuery)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext"/> class.
            </summary>
            <param name="stringBuilder">The string builder.</param>
            <param name="context">The context.</param>
            <param name="relationalQuery">The relational query</param>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.StringBuilder">
            <summary>
            Gets the string builder.
            </summary>
            <value>The string builder.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.Context">
            <summary>
            Gets the context.
            </summary>
            <value>The context.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.RelationalQuery">
            <summary>
            Gets the relational query.
            </summary>
            <value>The relational query.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.CurrentCalculusModel">
            <summary>
            Gets the current calculus model.
            </summary>
            <value>The current calculus model (<c>null</c> if you are topmost).</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.EnterCalculusModel(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel)">
            <summary>
            Enters the calculus model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.LeaveCalculusModel">
            <summary>
            Leaves the calculus model.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext.modelsStack">
            <summary>
            The models stack
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.TransformEqualCondition(System.Action,System.Action,System.Action{System.String},DatabaseSchemaReader.DataSchema.DataType,DatabaseSchemaReader.DataSchema.DataType)">
            <summary>
            Transforms the equal condition.
            </summary>
            <param name="writeLeft">The write left action.</param>
            <param name="writeRight">The write right action.</param>
            <param name="writeText">The write text action.</param>
            <param name="leftDataType">Type of the left data.</param>
            <param name="rightDataType">Type of the right data.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable(Slp.Evi.Storage.Relational.Query.ICalculusVariable,Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Writes the calculus variable.
            </summary>
            <param name="variable">The variable.</param>
            <param name="currentModel">The current model.</param>
            <param name="data"></param>
            
            
        </member>
        <member name="T:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable_Assignment_Visitor">
            <summary>
            Visitor for writing the calculus variable comming from assignment condition
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable_Assignment_Visitor.#ctor(Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable_Assignment_Visitor"/> class.
            </summary>
            <param name="queryBuilder">The query builder.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable_Assignment_Visitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="assignmentFromExpressionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.WriteCalculusVariable_Assignment_Visitor.QueryBuilder">
            <summary>
            Gets or sets the query builder.
            </summary>
            <value>The query builder.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,Slp.Evi.Storage.Database.Base.BaseSqlQueryBuilder.VisitorContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.IQueryResultReader">
            <summary>
            The SQL result reader
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.IQueryResultReader.HasNextRow">
            <summary>
            Gets a value indicating whether this instance has next row.
            </summary>
            <value><c>true</c> if this instance has next row; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.IQueryResultReader.Read">
            <summary>
            Reads the current row and moves to next one.
            </summary>
            <returns>Readed row, <c>null</c> if there is no row</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.IQueryResultRow">
            <summary>
            Single row in SQL result
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.IQueryResultRow.Columns">
            <summary>
            Gets the columns.
            </summary>
            <value>The columns.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.IQueryResultRow.GetColumn(System.String)">
            <summary>
            Gets the column.
            </summary>
            <param name="name">The column name.</param>
            <returns>The column.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.IQueryResultColumn">
            <summary>
            Single cell in SQL result
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.IQueryResultColumn.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.IQueryResultColumn.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.IQueryResultColumn.GetBooleanValue">
            <summary>
            Gets the boolean value.
            </summary>
            <returns><c>true</c> if the value is true, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.ISqlDatabase">
            <summary>
            Interface providing access to database specific
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlDatabase.GenerateQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the query.
            </summary>
            <param name="relationalQuery">The relational model.</param>
            <param name="context">The query context.</param>
            <returns>The SQL query</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlDatabase.ExecuteQuery(System.String)">
            <summary>
            Executes the query.
            </summary>
            <param name="query">The query.</param>
            <returns>The query result reader.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Database.ISqlDatabase.ConnectionString">
            <summary>
            Gets the connection string.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.ISqlDatabase.SqlType">
            <summary>
            Gets the type of the SQL connection.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlDatabase.GetTableNameUnquoted(System.String)">
            <summary>
            Gets the unquoted table name.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlDatabase.GetSchemaTableName(System.String)">
            <summary>
            Gets the name of table in the schema.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlDatabase.GetColumnNameUnquoted(System.String)">
            <summary>
            Gets the unquoted column name.
            </summary>
            <param name="columnName">Name of the column.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Database.ISqlDatabase.SqlTypeForString">
            <summary>
            Gets the SQL type for string.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.ISqlDatabase.SqlTypeForInt">
            <summary>
            Gets the SQL type for int.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Database.ISqlQueryBuilder">
            <summary>
            The SQL query builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.ISqlQueryBuilder.GenerateQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the query.
            </summary>
            <param name="relationalQuery">The calculus model.</param>
            <param name="context">The context.</param>
            <returns>The query string.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper">
            <summary>
            Wrapper over data reader
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper._db">
            <summary>
            The database
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper._dataReader">
            <summary>
            The data reader
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper._needsDisposeAction">
            <summary>
            The needs dispose action
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper._disposeAction">
            <summary>
            The dispose action
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper._currentRow">
            <summary>
            The current row
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.#ctor(Slp.Evi.Storage.Database.ISqlDatabase,System.Data.SqlClient.SqlDataReader,System.Func{System.Boolean},System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper"/> class.
            </summary>
            <param name="db">The database</param>
            <param name="dataReader">The data reader.</param>
            <param name="needsDisposeAction">The needs dispose action.</param>
            <param name="disposeAction">The dispose action.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.Init">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.FetchRow">
            <summary>
            Fetchs the row.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.HasNextRow">
            <summary>
            Gets a value indicating whether this instance has next row.
            </summary>
            <value><c>true</c> if this instance has next row; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.Read">
            <summary>
            Reads the current row and moves to next one.
            </summary>
            <returns>Readed row, <c>null</c> if there is no row</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow">
            <summary>
            Wrapper for a readed row
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow._database">
            <summary>
            The database
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow._columns">
            <summary>
            The columns
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow.#ctor(Slp.Evi.Storage.Database.ISqlDatabase,System.Collections.Generic.List{Slp.Evi.Storage.Database.IQueryResultColumn})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow"/> class.
            </summary>
            <param name="database"></param>
            <param name="columns">The columns.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow.Columns">
            <summary>
            Gets the columns.
            </summary>
            <value>The columns.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow.Create(Slp.Evi.Storage.Database.ISqlDatabase,System.Data.SqlClient.SqlDataReader)">
            <summary>
            Creates the specified data reader.
            </summary>
            <param name="database"></param>
            <param name="dataReader">The data reader.</param>
            <returns>IQueryResultRow.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderRow.GetColumn(System.String)">
            <summary>
            Gets the column.
            </summary>
            <param name="columnName">Name of the column.</param>
            <returns>The column.</returns>
            <exception cref="T:System.Exception">Asked for column that is not present</exception>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn">
            <summary>
            Wrapper for a column
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn._name">
            <summary>
            The name
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn._value">
            <summary>
            The value
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Reader.DataReaderWrapper.DataReaderColumn.GetBooleanValue">
            <summary>
            Gets the boolean value.
            </summary>
            <returns><c>true</c> if the value is true, <c>false</c> otherwise.</returns>
            <exception cref="T:System.Exception">Cannot convert value to boolean</exception>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb">
            <summary>
            MS SQL database vendor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.#ctor(Slp.Evi.Storage.Bootstrap.ISqlDbFactory,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.StartQuoting">
            <summary>
            The start delimiters
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.EndQuoting">
            <summary>
            The end delimiters
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.MiddleDelimiters">
            <summary>
            The middle delimiters
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.ExecuteQuery(System.String)">
            <summary>
            Executes the query.
            </summary>
            <param name="query">The query.</param>
            <returns>The query result reader.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.GetTableNameUnquoted(System.String)">
            <summary>
            Gets the unquoted table name.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.GetSchemaTableName(System.String)">
            <summary>
            Gets the name of table in the schema.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.GetColumnNameUnquoted(System.String)">
            <summary>
            Gets the unquoted column name.
            </summary>
            <param name="columnName">Name of the column.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.SqlTypeForString">
            <summary>
            Gets the SQL type for string.
            </summary>
            <value>The SQL type for string.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDb.SqlTypeForInt">
            <summary>
            Gets the SQL type for int.
            </summary>
            <value>The SQL type for int.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDbFactory">
            <summary>
            Sql factory for MS SQL
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDbFactory.CreateSqlDb(System.String)">
            <summary>
            Creates the SQL database connection.
            </summary>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Database.Vendor.MsSql.MsSqlDbFactory.CreateSqlQueryBuilder">
            <summary>
            Creates the SQL query builder.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.DBSchema.DbSchemaProvider">
            <summary>
            Provider for functions related to database schema.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.DBSchema.DbSchemaProvider._db">
            <summary>
            The provided database
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.DBSchema.DbSchemaProvider.#ctor(Slp.Evi.Storage.Database.ISqlDatabase)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.DBSchema.DbSchemaProvider"/> class.
            </summary>
            <param name="db">The provided database.</param>
        </member>
        <member name="M:Slp.Evi.Storage.DBSchema.DbSchemaProvider.ReadDatabaseSchema">
            <summary>
            Reads the database schema.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.DBSchema.DbSchemaProvider._tableCache">
            <summary>
            The table info cache
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.DBSchema.DbSchemaProvider.GetTableInfo(System.String)">
            <summary>
            Gets the table information.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>DatabaseTable.</returns>
            <exception cref="T:System.Exception">Table not found in database schema</exception>
        </member>
        <member name="T:Slp.Evi.Storage.DBSchema.IDbSchemaProvider">
            <summary>
            Interface for the provider for functions related to database schema.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.DBSchema.IDbSchemaProvider.GetTableInfo(System.String)">
            <summary>
            Gets the table information.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>DatabaseTable.</returns>
            <exception cref="T:System.Exception">Table not found in database schema</exception>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.ClassObjectMap">
            <summary>
            Object map for class
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.ClassObjectMap.#ctor(System.Uri,System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.ClassObjectMap"/> class.
            </summary>
            <param name="baseUri">The base URI.</param>
            <param name="classUri">The class URI.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.URI">
            <summary>
            Gets constant object URI or null if absent
            </summary>
            <value>The URI.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.DataTypeURI">
            <summary>
            Gets the datatype URI of the RDF term generated from this term map
            </summary>
            <value>The data type URI.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.Language">
            <summary>
            Gets the language tag of the RDF term generated from this term map
            </summary>
            <value>The language.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.Literal">
            <summary>
            Gets the literal value of the RDF term generated from this term map
            </summary>
            <value>The literal.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.ColumnName">
            <summary>
            Gets column or null if not set
            </summary>
            <value>The name of the column.</value>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.InverseExpression">
            <summary>
            Gets the inverse expression associated with this <see cref="T:TCode.r2rml4net.Mapping.ITermMap" /> or null if not set
            </summary>
            <value>The inverse expression.</value>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks>See http://www.w3.org/TR/r2rml/#inverse</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.IsColumnValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#from-column">column valued</a>
            </summary>
            <value><c>true</c> if this instance is column valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.IsConstantValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#constant">constant valued</a>
            </summary>
            <value><c>true</c> if this instance is constant valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.IsTemplateValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#from-template">template valued</a>
            </summary>
            <value><c>true</c> if this instance is template valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.Template">
            <summary>
            Gets template or null if absent
            </summary>
            <value>The template.</value>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.TermType">
            <summary>
            Gets <a href="http://www.w3.org/TR/r2rml/#term-map">term map's</a><a href="http://www.w3.org/TR/r2rml/#termtype">term type</a>
            </summary>
            <value>The type of the term.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.TermTypeURI">
            <summary>
            Returns term type set with configuration
            or a default value
            </summary>
            <value>The term type URI.</value>
            <remarks>Default value is described on http://www.w3.org/TR/r2rml/#dfn-term-type</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.BaseUri">
            <summary>
            Base mapping URI. It will be used to resolve relative values when generating terms
            </summary>
            <value>The base URI.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.Node">
            <summary>
            The node representing this <see cref="T:TCode.r2rml4net.Mapping.IMapBase" />
            </summary>
            <value>The node.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.ClassObjectMap.ClassObjectMapTermType">
            <summary>
            Term type for class object map
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.ClassObjectMapTermType.IsBlankNode">
            <summary>
            Gets value indicating whether the term map's term type is rr:BlankNode
            </summary>
            <value><c>true</c> if this instance is blank node; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.ClassObjectMapTermType.IsLiteral">
            <summary>
            Gets value indicating whether the term map's term type is rr:Literal
            </summary>
            <value><c>true</c> if this instance is literal; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassObjectMap.ClassObjectMapTermType.IsURI">
            <summary>
            Gets value indicating whether the term map's term type is rr:IRI
            </summary>
            <value><c>true</c> if this instance is URI; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.ClassPredicateMap">
            <summary>
            Predicate map for class
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.ClassPredicateMap.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.ClassPredicateMap"/> class.
            </summary>
            <param name="baseUri">The base URI.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.URI">
            <summary>
            Get the URI
            </summary>
            <value>The URI.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.ColumnName">
            <summary>
            Gets column or null if not set
            </summary>
            <value>The name of the column.</value>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.InverseExpression">
            <summary>
            Gets the inverse expression associated with this <see cref="T:TCode.r2rml4net.Mapping.ITermMap" /> or null if not set
            </summary>
            <value>The inverse expression.</value>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks>See http://www.w3.org/TR/r2rml/#inverse</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.IsColumnValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#from-column">column valued</a>
            </summary>
            <value><c>true</c> if this instance is column valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.IsConstantValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#constant">constant valued</a>
            </summary>
            <value><c>true</c> if this instance is constant valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.IsTemplateValued">
            <summary>
            Gets value indicating whether <a href="http://www.w3.org/TR/r2rml/#term-map">term map</a> is <a href="http://www.w3.org/TR/r2rml/#from-template">template valued</a>
            </summary>
            <value><c>true</c> if this instance is template valued; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.Template">
            <summary>
            Gets template or null if absent
            </summary>
            <value>The template.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.TermType">
            <summary>
            Gets <a href="http://www.w3.org/TR/r2rml/#term-map">term map's</a><a href="http://www.w3.org/TR/r2rml/#termtype">term type</a>
            </summary>
            <value>The type of the term.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.TermTypeURI">
            <summary>
            Returns term type set with configuration
            or a default value
            </summary>
            <value>The term type URI.</value>
            <remarks>Default value is described on http://www.w3.org/TR/r2rml/#dfn-term-type</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.BaseUri">
            <summary>
            Base mapping URI. It will be used to resolve relative values when generating terms
            </summary>
            <value>The base URI.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.Node">
            <summary>
            The node representing this <see cref="T:TCode.r2rml4net.Mapping.IMapBase" />
            </summary>
            <value>The node.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.ClassPredicateMap.ClassPredicateMapTermType">
            <summary>
            Term type for class predicate term
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.ClassPredicateMapTermType.IsBlankNode">
            <summary>
            Gets value indicating whether the term map's term type is rr:BlankNode
            </summary>
            <value><c>true</c> if this instance is blank node; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.ClassPredicateMapTermType.IsLiteral">
            <summary>
            Gets value indicating whether the term map's term type is rr:Literal
            </summary>
            <value><c>true</c> if this instance is literal; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.ClassPredicateMap.ClassPredicateMapTermType.IsURI">
            <summary>
            Gets value indicating whether the term map's term type is rr:IRI
            </summary>
            <value><c>true</c> if this instance is URI; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.MappingProcessor">
            <summary>
            Processor for R2RML mapping
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingProcessor.#ctor(TCode.r2rml4net.IR2RML)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.MappingProcessor"/> class.
            </summary>
            <param name="mapping">The R2RML mapping.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.MappingProcessor.Mapping">
            <summary>
            Gets the R2RML mapping.
            </summary>
            <value>The R2RML mapping.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Mapping.MappingProcessor.Cache">
            <summary>
            Gets the R2RML cache.
            </summary>
            <value>The R2RML cache.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingProcessor.ProcessPattern(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the SPARQL algebra.
            </summary>
            <param name="graphPattern">The SPARQL algebra.</param>
            <param name="context">The query context.</param>
            <returns>The processed SPARQL algebra.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.MappingTransformer">
            <summary>
            Mapping transformer
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Mapping.MappingTransformer._mappingProcessor">
            <summary>
            The mapping processor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingTransformer.#ctor(Slp.Evi.Storage.Mapping.MappingProcessor)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.MappingTransformer"/> class.
            </summary>
            <param name="mappingProcessor">The mapping processor.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingTransformer.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/>
            </summary>
            <param name="triplePattern">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingTransformer.ConstrainTriplePattern(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern},TCode.r2rml4net.Mapping.ITriplesMap,TCode.r2rml4net.Mapping.ISubjectMap,System.Uri,System.Collections.Generic.List{TCode.r2rml4net.Mapping.IGraphMap})">
            <summary>
            Constrains the triple pattern.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="patterns">The patterns.</param>
            <param name="tripleMap">The triple map.</param>
            <param name="subjectMap">The subject map.</param>
            <param name="classUri">The class URI.</param>
            <param name="graphMaps">The graph maps.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingTransformer.ConstrainTriplePattern(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern},TCode.r2rml4net.Mapping.ITriplesMap,TCode.r2rml4net.Mapping.ISubjectMap,TCode.r2rml4net.Mapping.IPredicateMap,TCode.r2rml4net.Mapping.IRefObjectMap,System.Collections.Generic.List{TCode.r2rml4net.Mapping.IGraphMap})">
            <summary>
            Constrains the triple pattern.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="patterns">The patterns.</param>
            <param name="tripleMap">The triple map.</param>
            <param name="subjectMap">The subject map.</param>
            <param name="predicateMap">The predicate map.</param>
            <param name="refObjectMap">The reference object map.</param>
            <param name="graphMaps">The graph maps.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.MappingTransformer.ConstrainTriplePattern(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern},TCode.r2rml4net.Mapping.ITriplesMap,TCode.r2rml4net.Mapping.ISubjectMap,TCode.r2rml4net.Mapping.IPredicateMap,TCode.r2rml4net.Mapping.IObjectMap,System.Collections.Generic.List{TCode.r2rml4net.Mapping.IGraphMap})">
            <summary>
            Constrains the triple pattern.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="patterns">The patterns.</param>
            <param name="tripleMap">The triple map.</param>
            <param name="subjectMap">The subject map.</param>
            <param name="predicateMap">The predicate map.</param>
            <param name="objectMap">The object map.</param>
            <param name="graphMaps">The graph maps.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.R2RMLCache">
            <summary>
            Cache for R2RML
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.R2RMLCache.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.R2RMLCache"/> class.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Mapping.R2RMLCache._sqlStatementCache">
            <summary>
            The SQL statement cache
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.R2RMLCache.GetSqlStatement(TCode.r2rml4net.Mapping.ITriplesMap)">
            <summary>
            Gets the SQL statement.
            </summary>
            <param name="triplesMap">The triples map.</param>
            <returns>SQL statement</returns>
        </member>
        <member name="F:Slp.Evi.Storage.Mapping.R2RMLCache._sqlTableCache">
            <summary>
            The SQL table cache
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.R2RMLCache.GetSqlTable(TCode.r2rml4net.Mapping.ITriplesMap)">
            <summary>
            Gets the SQL table.
            </summary>
            <param name="triplesMap">The triples map.</param>
            <returns>SQL table name</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2">
            <summary>
            Cache dictionary
            </summary>
            <typeparam name="TK">Key type</typeparam>
            <typeparam name="T">Value type</typeparam>
        </member>
        <member name="F:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2._getFunc">
            <summary>
            The get value function
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2._cache">
            <summary>
            The cache
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2"/> class.
            </summary>
            <param name="getFunc">The get value from key function.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.R2RMLCache.CacheDictionary`2.GetValueFor(`0)">
            <summary>
            Gets the value for the key.
            </summary>
            <param name="key">The key.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Mapping.Utils.FixesExtensions">
            <summary>
            Extension class for r2rml4net fixes
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Mapping.Utils.FixesExtensions.GetJoinConditions(TCode.r2rml4net.Mapping.IRefObjectMap)">
            <summary>
            Gets the join conditions.
            </summary>
            <param name="refObjectPattern">The reference object pattern.</param>
            <returns>IEnumerable&lt;JoinCondition&gt;.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Query.Optimizers">
            <summary>
            Class Optimizers.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.Optimizers._context">
            <summary>
            The context
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.Optimizers._relationalOptimizers">
            <summary>
            The relational optimizers
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.Optimizers._sparqlOptimizers">
            <summary>
            The SPARQL optimizers
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Query.Optimizers.#ctor(Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Query.Optimizers" /> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.Optimizers.Optimize(Slp.Evi.Storage.Relational.Query.RelationalQuery)">
            <summary>
            Optimizes the algebra on the fly.
            </summary>
            <param name="algebra">The algebra.</param>
            <returns>The optimized algebra.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Query.Optimizers.Optimize(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery)">
            <summary>
            Optimizes the algebra on the fly.
            </summary>
            <param name="algebra">The SPARQL query.</param>
            <returns>The optimized SPARQL query.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Query.QueryNamingHelpers">
            <summary>
            The query naming helpers.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.#ctor(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Query.QueryNamingHelpers"/> class.
            </summary>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.GetSourceOfVariable(Slp.Evi.Storage.Relational.Query.ICalculusVariable,Slp.Evi.Storage.Relational.Query.Sources.CalculusModel)">
            <summary>
            Gets the source of variable.
            </summary>
            <param name="variable">The variable.</param>
            <param name="currentModel">The current model.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.GetSourceConditionName(Slp.Evi.Storage.Relational.Query.ISourceCondition)">
            <summary>
            Gets the name of the source condition.
            </summary>
            <param name="sourceCondition">The source condition.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.GetVariableName(Slp.Evi.Storage.Relational.Query.ISourceCondition,Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Gets the name of the variable.
            </summary>
            <param name="sourceCondition">The source condition.</param>
            <param name="variable">The variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.AddSourceCondition(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Query.ISourceCondition)">
            <summary>
            Adds the source condition.
            </summary>
            <param name="calculusModel">The calculus model.</param>
            <param name="sourceCondition">The source condition.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.AddAssignmentCondition(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Query.IAssignmentCondition)">
            <summary>
            Adds the assignment condition.
            </summary>
            <param name="calculusModel">The calculus model.</param>
            <param name="assignmentCondition">The assignment condition.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryNamingHelpers.GetSourceCondtion(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Gets the tuple from source condtion.
            </summary>
            <param name="parentModel">The parent model.</param>
            <param name="source">The source we are looking for.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Query.QueryProcessor">
            <summary>
            Query processor
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._mapping">
            <summary>
            The mapping processor
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._db">
            <summary>
            The database
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._sparqlBuilder">
            <summary>
            The sparql algebra builder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._factory">
            <summary>
            The factory used to generate classes
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._schemaProvider">
            <summary>
            The database schema provider
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryProcessor._relationalBuilder">
            <summary>
            The relational builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryProcessor.#ctor(Slp.Evi.Storage.Database.ISqlDatabase,TCode.r2rml4net.IR2RML,Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Query.QueryProcessor" /> class.
            </summary>
            <param name="db">The database.</param>
            <param name="mapping">The mapping.</param>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryProcessor.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes the query.
            </summary>
            <param name="rdfHandler">The RDF handler.</param>
            <param name="resultsHandler">The results handler.</param>
            <param name="sparqlQuery">The sparql query.</param>
            <exception cref="T:System.ArgumentNullException">
            resultsHandler;Cannot handle a Ask query with a null SPARQL Results Handler
            or
            rdfHandler;Cannot handle a Graph result with a null RDF Handler
            or
            rdfHandler;Cannot handle a Graph result with a null RDF Handler
            or
            resultsHandler;Cannot handle SPARQL Results with a null Results Handler
            </exception>
            <exception cref="T:System.Exception">Unable to process the results of an Unknown query type</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryProcessor.ProcessResult(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Database.IQueryResultReader)">
            <summary>
            Processes the query result.
            </summary>
            <param name="rdfHandler">The RDF handler.</param>
            <param name="resultsHandler">The results handler.</param>
            <param name="originalQuery">The original query.</param>
            <param name="context">The query context.</param>
            <param name="sqlAlgebra">The SQL algebra.</param>
            <param name="result">The SQL execution result.</param>
            <exception cref="T:System.Exception">
            Expected a column from sql query execution
            or
            Expected a single column from sql query execution
            or
            Expected a row from sql query execution
            or
            Expected 3 value binders in construct or describe query
            or
            Unable to process the results of an Unknown query type
            </exception>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryProcessor.ProcessConstructTemplate(VDS.RDF.IRdfHandler,Slp.Evi.Storage.Database.IQueryResultRow,VDS.RDF.Query.Patterns.GraphPattern,Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the construct template.
            </summary>
            <param name="rdfHandler">The RDF handler.</param>
            <param name="row">The database row.</param>
            <param name="template">The template.</param>
            <param name="sqlAlgebra">The SQL algebra.</param>
            <param name="context">The query context.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryProcessor.GenerateSqlAlgebra(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the SQL algebra.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SQL algebra.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Query.QueryContext">
            <summary>
            The query context.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryContext._blankNodesSubjects">
            <summary>
            The blank nodes subjects.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryContext._blankNodesObjects">
            <summary>
            The blank nodes objects.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryContext._usedVariables">
            <summary>
            The used variables
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryContext._queryNamingHelpers">
            <summary>
            The query naming helpers
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Query.QueryContext._optimizers">
            <summary>
            The optimizers
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryContext.#ctor(VDS.RDF.Query.SparqlQuery,Slp.Evi.Storage.Mapping.MappingProcessor,Slp.Evi.Storage.Database.ISqlDatabase,Slp.Evi.Storage.DBSchema.IDbSchemaProvider,VDS.RDF.INodeFactory,Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Query.QueryContext" /> class.
            </summary>
            <param name="originalQuery">The original query.</param>
            <param name="mapping">The mapping.</param>
            <param name="db">The database.</param>
            <param name="schemaProvider">The schema provider.</param>
            <param name="nodeFactory">The node factory.</param>
            <param name="factory">The storage factory</param>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.SchemaProvider">
            <summary>
            Gets the schema provider.
            </summary>
            <value>The schema provider.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.OriginalQuery">
            <summary>
            Gets the original query.
            </summary>
            <value>The original query.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.Mapping">
            <summary>
            Gets the mapping.
            </summary>
            <value>The mapping.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.NodeFactory">
            <summary>
            Gets the node factory.
            </summary>
            <value>The node factory.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.OriginalAlgebra">
            <summary>
            Gets the original algebra.
            </summary>
            <value>The original algebra.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.Db">
            <summary>
            Gets the database.
            </summary>
            <value>The database.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.QueryNamingHelpers">
            <summary>
            Gets the query naming helpers.
            </summary>
            <value>The query naming helpers.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Query.QueryContext.Optimizers">
            <summary>
            The optimizers
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryContext.GetBlankNodeSubjectForValue(VDS.RDF.INodeFactory,System.Object)">
            <summary>
            Gets the blank node subject for value.
            </summary>
            <param name="factory">The factory.</param>
            <param name="value">The value.</param>
            <returns>Node.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryContext.GetBlankNodeObjectForValue(VDS.RDF.INodeFactory,System.Object)">
            <summary>
            Gets the blank node object for value.
            </summary>
            <param name="factory">The factory.</param>
            <param name="value">The value.</param>
            <returns>Node.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Query.QueryContext.CreateSparqlVariable">
            <summary>
            Creates the sparql variable.
            </summary>
            <returns>The variable name.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.EviQueryableStorage">
            <summary>
            The <see cref="T:VDS.RDF.Storage.IQueryableStorage" /> which creates an RDB2RDF wrapper
            over a relational database
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.EviQueryableStorage._queryProcessor">
            <summary>
            The query processor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.#ctor(Slp.Evi.Storage.Database.ISqlDatabase,TCode.r2rml4net.IR2RML,Slp.Evi.Storage.Bootstrap.IEviQueryableStorageFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.EviQueryableStorage" /> class.
            </summary>
            <param name="db">The database.</param>
            <param name="mapping">The mapping.</param>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Makes a SPARQL Query against the underlying store processing the resulting Graph/Result Set with a handler of your choice
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the underlying store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns><see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the Sparql Query</returns>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.DeleteGraph(System.String)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to be deleted</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks><strong>Note:</strong> Not all Stores are capable of Deleting a Graph so it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.DeleteGraph(System.Uri)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to be deleted</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks><strong>Note:</strong> Not all Stores are capable of Deleting a Graph so it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.ListGraphs">
            <summary>
            Gets a List of Graph URIs for the graphs in the store
            </summary>
            <returns>IEnumerable&lt;Uri&gt;.</returns>
            <exception cref="T:System.Exception">
            Did not get uri in result set as expected
            or
            Did not get the variable in result set as expected
            or
            Did not get a SPARQL Result Set as expected
            </exception>
            <remarks>Implementations should implement this method only if they need to provide a custom way of listing Graphs.  If the Store for which you are providing a manager can efficiently return the Graphs using a SELECT DISTINCT ?g WHERE { GRAPH ?g { ?s ?p ?o } } query then there should be no need to implement this function.</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the Store using the RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
            <remarks>Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the Store using the RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
            <exception cref="T:System.ArgumentException">Graph uri cannot be null  or empty;graphUri</exception>
            <remarks>Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <remarks><para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para></remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks><para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para></remarks>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.ParentServer">
            <summary>
            Gets the Parent Server on which this store is hosted (if any)
            </summary>
            <value>The parent server.</value>
            <exception cref="T:System.NotImplementedException"></exception>
            <remarks>For storage backends which support multiple stores this is useful because it provides a way to access all the stores on that backend.  For stores which are standalone they should simply return null</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store
            </summary>
            <param name="g">Graph to Save</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks>Uri of the Graph should be taken from the <see cref="P:VDS.RDF.IGraph.BaseUri">BaseUri</see> property
            <br /><br />
            Behaviour of this method with regards to whether it overwrites/updates/merges with existing Graphs of the same Uri is up to the implementor and may be dependent on the underlying store.  Implementors <strong>should</strong> state in the XML comments for their implementations what behaviour is implemented.</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks><para>
              <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>MUST</strong> allow for either the additions or removals argument to be null
            </para></remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <remarks><para>
              <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>MUST</strong> allow for either the additions or removals argument to be null
            </para></remarks>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.DeleteSupported">
            <summary>
            Gets whether the deletion of graphs is supported
            </summary>
            <value><c>true</c> if [delete supported]; otherwise, <c>false</c>.</value>
            <remarks>Some Stores do not support the deletion of Graphs and may as designated in the interface definition throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the <strong>DeleteGraph()</strong> method is called.  This property allows for calling code to check in advance whether Deletion of Graphs is supported.</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.IOBehaviour">
            <summary>
            Gets the Save Behaviour the Store uses
            </summary>
            <value>The io behaviour.</value>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.IsReadOnly">
            <summary>
            Gets whether the connection with the underlying Store is read-only
            </summary>
            <value><c>true</c> if this instance is read only; otherwise, <c>false</c>.</value>
            <remarks>Any Manager which indicates it is read-only should also return false for the <see cref="P:VDS.RDF.Storage.IStorageCapabilities.UpdateSupported">UpdatedSupported</see> property and should throw a <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the <strong>SaveGraph()</strong> or <strong>UpdateGraph()</strong> methods are called</remarks>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.IsReady">
            <summary>
            Gets whether the connection with the underlying Store is ready for use
            </summary>
            <value><c>true</c> if this instance is ready; otherwise, <c>false</c>.</value>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.ListGraphsSupported">
            <summary>
            Gets whether the Store supports Listing Graphs
            </summary>
            <value><c>true</c> if [list graphs supported]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.EviQueryableStorage.UpdateSupported">
            <summary>
            Gets whether the triple level updates are supported
            </summary>
            <value><c>true</c> if [update supported]; otherwise, <c>false</c>.</value>
            <remarks>Some Stores do not support updates at the Triple level and may as designated in the interface definition throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the <strong>UpdateGraph()</strong> method is called.  This property allows for calling code to check in advance whether Updates are supported</remarks>
        </member>
        <member name="M:Slp.Evi.Storage.EviQueryableStorage.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1">
            <summary>
            The base class for relational optimizers
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.#ctor(Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1"/> class.
            </summary>
            <param name="optimizerImplementation">The optimizer implementation.</param>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1._optimizerImplementation">
            <summary>
            The optimizer implementation
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.OptimizerImplementation">
            <summary>
            Gets the optimizer implementation.
            </summary>
            <value>The optimizer implementation.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.OptimizationContext">
            <summary>
            The optimization context
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.OptimizationContext.Context">
            <summary>
            Gets or sets the query context.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.OptimizationContext.Data">
            <summary>
            Gets or sets the data.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.Optimize(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Optimizes the specified query.
            </summary>
            <param name="query">The query.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.OptimizeRelationalQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Optimizes the relational query.
            </summary>
            <param name="relationalQuery">The relational query.</param>
            <param name="optimizationContext">The optimization context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CreateInitialContext(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the initial context
            </summary>
            <param name="query">The query</param>
            <param name="context">The context</param>
            <returns></returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CreateInitialData(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the initial data.
            </summary>
            <param name="query">The query</param>
            <param name="context">The context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Relational.Query.IAssignmentCondition,Slp.Evi.Storage.Relational.Query.IAssignmentCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Relational.Query.ISourceCondition,Slp.Evi.Storage.Relational.Query.ISourceCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Relational.Query.ICalculusSource,Slp.Evi.Storage.Relational.Query.ICalculusSource,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Relational.Query.IFilterCondition,Slp.Evi.Storage.Relational.Query.IFilterCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer">
            <summary>
            Comparison of constants
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.#ctor">
            <summary>
            Creates an instance of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer"/>
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation"/> optimizer implementation.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.EqualityResults">
            <summary>
            Enumeration for the result of the <see cref="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.CheckEquality(Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)"/> method
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.EqualityResults.Always">
            <summary>
            The operands are always equal
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.EqualityResults.Sometimes">
            <summary>
            The operands may be equal
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.EqualityResults.Never">
            <summary>
            The operands are never equal
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.CheckEquality(Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Checks the equality of the operands.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
            <param name="data">The passed data.</param>
            <returns>The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.EqualityResults"/> of the check.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConstantExpressionEqualityOptimizer.ConstantExpressionEqualityOptimizerImplementation.AreConstantExpressionsEqual(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression)">
            <summary>
            Checks whether two constant expressions are equal or not.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
            <returns>Returns <c>true</c> if the left operand is equal to the right one, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer">
            <summary>
            The optimizer of <c>IS NULL</c> statements
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullCalculator">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/> instance for this optimizer
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.#ctor">
            <summary>
            Constructs an instance of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.CreateInitialData(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the initial data.
            </summary>
            <param name="query"></param>
            <param name="context"></param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.OptimizeRelationalQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult}.OptimizationContext)">
            <summary>
            Optimizes the relational query.
            </summary>
            <param name="relationalQuery">The relational query.</param>
            <param name="optimizationContext">The optimization context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.ProcessVisit(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult}.OptimizationContext)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.ProcessVisit(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult}.OptimizationContext)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult}.OptimizationContext)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation">
            <summary>
            The implementation of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer"/>
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation._isNullCalculator">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/> instance for this optimizer
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation.#ctor(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation"/> class.
            </summary>
            <param name="isNullCalculator">The is null calculator.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation.IsNullCalculator">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/> instance for this optimizer
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation.CheckPresentAnalysisResult(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Checks whether the analysis result is present.
            </summary>
            <param name="analyzeResult">The analysis result.</param>
            <param name="context">The query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizer.IsNullOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator">
            <summary>
            Calculates the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues"/> from the calculus model
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter">
            <summary>
            The parameter for <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/> transformer
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter.Result">
            <summary>
            Gets the analysis result
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter.Context">
            <summary>
            Gets the query context.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter.#ctor(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter"/> class.
            </summary>
            <param name="result">The analysis result.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator.IsNullCalculatorParameter)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues">
            <summary>
            The aggregation result of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/>.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues._isNullConditions">
            <summary>
            The is null columns
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues._isNotNullConditions">
            <summary>
            The is not null columns
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.#ctor">
            <summary>
            Creates an instance of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.MergeWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues)">
            <summary>
            Merges with another aggregation result.
            </summary>
            <param name="other">The other.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.MergeWith(System.Collections.Generic.Dictionary{Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.HashSet{Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition}},System.Collections.Generic.Dictionary{Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.HashSet{Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition}})">
            <summary>
            Merges the <paramref name="source"/> dictionary with the <paramref name="with"/> dictionary
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IntersectsWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues)">
            <summary>
            Intersects with another aggregation result.
            </summary>
            <param name="other">The other.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IntersectsWith(System.Collections.Generic.Dictionary{Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.HashSet{Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition}},System.Collections.Generic.Dictionary{Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.HashSet{Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition}})">
            <summary>
            Intersects the <paramref name="source"/> dictionary with the <paramref name="with"/> dictionary
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.GetInverse">
            <summary>
            Gets the inverse.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.AddIsNullCondition(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition)">
            <summary>
            Adds the is null condition.
            </summary>
            <param name="condition">The condition.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.AddIsNotNull(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Adds the is not null information.
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IsInNotNullConditions(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Determines whether the column is in "is not null list".
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IsInNotNullConditions(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition)">
            <summary>
            Determines whether the condition is in "is not null list" as the reason.
            </summary>
            <param name="condition">The condition.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IsInNullConditions(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Determines whether the column is in "is not null list".
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAggregatedValues.IsInNullConditions(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition)">
            <summary>
            Determines whether the condition is in "is null list" as the reason.
            </summary>
            <param name="condition">The condition.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult">
            <summary>
            The overall result of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullCalculator"/>
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult._storedValues">
            <summary>
            The stored values
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult._nestedNegationsCount">
            <summary>
            The nested negations count
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.CurrentSource">
            <summary>
            The current source
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult._currentSources">
            <summary>
            The stack of current sources
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.#ctor(Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult"/> class.
            </summary>
            <param name="currentSource">The current source.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.GetValue(Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Gets the result.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.GetCurrentValue">
            <summary>
            Gets the result for the current source.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.CopyTo(Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult)">
            <summary>
            Copies data to another instance.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.PushCurrentSource(Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Pushes the source as the current source.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.PopCurrentSource">
            <summary>
            Removes the last current source and sets the previous one.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.EnterNegationCondition">
            <summary>
            Increases the current negation count.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.LeaveNegationCondition">
            <summary>
            Decreases the current negation count.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.IsCurrentlyNegated">
            <summary>
            Determines whether we are currently in a negated condition.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.IsNullOptimizerHelpers.IsNullOptimizerAnalyzeResult.HasValueForSource(Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Determines whether there is a stored value for the desired source.
            </summary>
            <param name="calculusSource">The calculus source.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer">
            <summary>
            Self-join optimizer
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.ProcessVisit(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.CreateInitialData(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the initial data.
            </summary>
            <param name="query">The query</param>
            <param name="context">The context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.OptimizeRelationalQuery(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Optimizes the relational query.
            </summary>
            <param name="relationalQuery">The relational query.</param>
            <param name="optimizationContext">The optimization context.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation">
            <summary>
            The implementation of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer.SelfJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap">
            <summary>
            The type representing satisfaction map
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap._storeDictionary">
            <summary>
            The satisfaction storage
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap._presentTables">
            <summary>
            The present tables
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap._context">
            <summary>
            The context
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap._satisfiedSatisfactions">
            <summary>
            The satisfied satisfactions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.#ctor(System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Sources.SqlTable},Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Prevents a default instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap"/> class from being created.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.CreateInitialSatisfactionMap">
            <summary>
            Creates the initial satisfaction map.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.CreateInitialSatisfactionMap(System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Sources.SqlTable},Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the initial satisfaction map
            </summary>
            <param name="presentTables">Tables present in the model</param>
            <param name="context">The query context</param>
            <returns></returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.GetSelfJoinConstraints(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Gets the self join constraints of a table
            </summary>
            <param name="sqlTable">The SQL table</param>
            <param name="replaceByTable">The table that will be used to replace the <paramref name="sqlTable"/></param>
            <param name="context">The query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.GetSatisfactionsFromMap(Slp.Evi.Storage.Relational.Query.Sources.SqlTable)">
            <summary>
            Gets the satisfactions for table <paramref name="table"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.GetSatisfactionFromMap(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Query.Sources.SqlTable)">
            <summary>
            Gets the satisfaction for tables <paramref name="table"/> and <paramref name="otherTable"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.MarkAsSatisfied(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction)">
            <summary>
            Marks <paramref name="satisfaction"/>as satisfied.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.GetSatisfiedSatisfactions">
            <summary>
            Gets the satisfied satisfactions.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.IntersectWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap)">
            <summary>
            Intersects with the <paramref name="other"/> map.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap.MergeWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SatisfactionMap)">
            <summary>
            Merges with the <paramref name="other"/> map.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator">
            <summary>
            Calculator of self join constraints, able to find self join of SqlTables according to filter conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.ProcessSelfJoinConditions(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.IFilterCondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Sources.SqlTable},Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData}.OptimizationContext)">
            <summary>
            Processes the self join conditions.
            </summary>
            <param name="filterConditions">The filter conditions.</param>
            <param name="presentTables"></param>
            <param name="data">The data.</param>
            <returns>List of all tables that are self joined</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="alwaysFalseCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="alwaysTrueCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="conjunctionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="disjunctionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="equalExpressionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="equalVariablesCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="isNullCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsCalculator.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="negationCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction">
            <summary>
            Class representing unsatisfied self-join constraints between tables
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.SqlTable">
            <summary>
            The SQL table
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.ReplaceByTable">
            <summary>
            The SQL table that will be used to replace <see cref="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.SqlTable"/>
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction._uniqueConstraints">
            <summary>
            The list of unique constraints between tables
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction._sqlTableColumnsEqualExpressions">
            <summary>
            The <see cref="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.SqlTable"/> map from columns to their equal expressions
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction._replaceByTableColumnsEqualExpressions">
            <summary>
            The <see cref="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.ReplaceByTable"/> map from columns to their equal expressions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.#ctor(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Query.Sources.SqlTable,System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint})">
            <summary>
            Constructs an instance of <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction"/>
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.IsSatisfied">
            <summary>
            Determines whether the self join rules are satisfied and the <see cref="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.SqlTable"/> can be replaced with <see cref="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.ReplaceByTable"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.ProcessEqualVariablesCondition(Slp.Evi.Storage.Relational.Query.Sources.SqlColumn,Slp.Evi.Storage.Relational.Query.Sources.SqlColumn)">
            <summary>
            Processes the condition that two <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn"/> variables are equal
            </summary>
            <param name="leftVariable">The left variable</param>
            <param name="rightVariable">The right variable</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.SatisfyConditionsWithVariable(System.String)">
            <summary>
            Satisfies the conditions with variable specified by <paramref name="name"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.ProcessVariableEqualToVariablesCondition(Slp.Evi.Storage.Relational.Query.Sources.SqlColumn,Slp.Evi.Storage.Relational.Query.IExpression)">
            <summary>
            Process the variable equal to variables condition.
            </summary>
            <param name="leftVariable">The left variable.</param>
            <param name="rightOperand">The right operand.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.CheckExpression(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}},System.String,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression)">
            <summary>
            Checks the expression, whether the same is present also in the map <paramref name="tableColumnsEqualExpressions"/> for the variable
            specified by <paramref name="variableName"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.AreEqual(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression)">
            <summary>
            Determines whether the expression are equal.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.AddExpression(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}},System.String,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression)">
            <summary>
            Adds the expression to the map <paramref name="tableColumnsEqualExpressions"/>
            </summary>
            <param name="tableColumnsEqualExpressions">The table columns equal expressions map.</param>
            <param name="variableName">Name of the variable.</param>
            <param name="expression">The expression.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.IntersectWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction)">
            <summary>
            Intersects with the <paramref name="other"/> satisfaction.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.IntersectColumnsEqualLists(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}})">
            <summary>
            Intersects the columns equal lists.
            </summary>
            <param name="sqlTableColumnsEqualExpressions">The SQL table columns equal expressions.</param>
            <param name="otherSqlTableColumnsEqualExpressions">The other SQL table columns equal expressions.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.MergeWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction)">
            <summary>
            Merges with the <paramref name="other"/> satisfaction.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinConstraintsSatisfaction.MergeColumnsEqualLists(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression}})">
            <summary>
            Merges the columns equal lists.
            </summary>
            <param name="sqlTableColumnsEqualExpressions">The SQL table columns equal expressions.</param>
            <param name="otherSqlTableColumnsEqualExpressions">The other SQL table columns equal expressions.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData">
            <summary>
            The data for <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizer"/>
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData._variablesMap">
            <summary>
            The variables map
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData.AddReplaceColumnInformation(Slp.Evi.Storage.Relational.Query.Sources.SqlColumn,Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Adds the information that the column was replaced.
            </summary>
            <param name="sqlColumn">The SQL column to be replaced.</param>
            <param name="targetColumn">The target column that will be used instead of <paramref name="sqlColumn"/>.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData.LoadOtherData(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData)">
            <summary>
            Loads data from other context.
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData.IsReplaced(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Determines whether the specified calculus variable is replaced.
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
            <returns><c>true</c> if the specified calculus variable is replaced; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinOptimizerData.GetReplacingVariable(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Gets the variable that is replacing <paramref name="calculusVariable"/>.
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinValueBindersOptimizerImplementation">
            <summary>
            The implementation of the transformation <see cref="T:Slp.Evi.Storage.Relational.Query.IValueBinder"/> to replace the variables
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinValueBindersOptimizerImplementation.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder"/>
            </summary>
            <param name="baseValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinValueBindersOptimizerImplementation.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder"/>
            </summary>
            <param name="emptyValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinValueBindersOptimizerImplementation.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder"/>
            </summary>
            <param name="coalesceValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.SelfJoinValueBindersOptimizerImplementation.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder"/>
            </summary>
            <param name="switchValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint">
            <summary>
            Class representing a unique constraint.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint._databaseConstraint">
            <summary>
            The database constraint
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint._notEqualColumns">
            <summary>
            The not equal columns
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.#ctor(DatabaseSchemaReader.DataSchema.DatabaseConstraint)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint"/> class.
            </summary>
            <param name="databaseConstraint">The database constraint.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.Satisfied">
            <summary>
            Gets a value indicating whether this <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint"/> is satisfied.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.DatabaseConstraint">
            <summary>
            Gets the database constraint.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.HasNotEqualColumn(System.String)">
            <summary>
            Determines whether this constraint has a column with name specified by <paramref name="name"/>
            which is not marked as equal
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.MarkAsEqual(System.String)">
            <summary>
            Marks a column with name specified by <paramref name="name"/> as equal.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.IntersectWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint)">
            <summary>
            Intersects with the other <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint" />
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint.MergeWith(Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint)">
            <summary>
            Merges with the other <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.SelfJoinOptimizerHelpers.UniqueConstraint" />
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer">
            <summary>
            CONCAT in equal optimization
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer"/> class.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer"/> optimizer implementation.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation._comparer">
            <summary>
            The <see cref="T:Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternComparer"/> used in this class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ExpandEquals(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Expands the equals operator.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
            <param name="data">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ExpandEquals(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Expands the equals operator.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
            <param name="data">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ExpandEquals(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Expands the equals operator.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
            <param name="data">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ProcessConcatenation(Slp.Evi.Storage.Relational.Query.IExpression[],Slp.Evi.Storage.Relational.Query.IExpression[],Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Processes the concatenation.
            </summary>
            <param name="leftParts">The left parts.</param>
            <param name="rightParts">The right parts.</param>
            <param name="data">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ConvertToCondition(Slp.Evi.Storage.Common.Optimization.PatternMatching.MatchCondition,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Converts to condition.
            </summary>
            <param name="matchCondition">The match condition to convert.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ConvertToExpression(Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Converts to expression.
            </summary>
            <param name="pattern">The pattern to convert.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.ConvertToExpression(Slp.Evi.Storage.Common.Optimization.PatternMatching.PatternItem,System.Boolean,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Converts to expression.
            </summary>
            <param name="patternItem">The pattern item.</param>
            <param name="isIriEscaped">if set to <c>true</c> the value is iri escaped.</param>
            <param name="context">The context.</param>
            <returns>IExpression.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.GetPattern(Slp.Evi.Storage.Relational.Query.IExpression[])">
            <summary>
            Gets the pattern.
            </summary>
            <param name="parts">The expression to build the pattern.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.Optimizers.ConcatenationInEqualConditionOptimizer.ConcatenationInEqualConditionOptimizerImplementation.CanOptimize(Slp.Evi.Storage.Relational.Query.IExpression[])">
            <summary>
            Determines whether we can optimize the specified parts.
            </summary>
            <param name="parts">The parts.</param>
            <returns><c>true</c> if we can optimize the specified parts; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Optimization.IRelationalOptimizer">
            <summary>
            Interface for relational optimization
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Optimization.IRelationalOptimizer.Optimize(Slp.Evi.Storage.Relational.Query.RelationalQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Optimizes the specified query.
            </summary>
            <param name="query">The query.</param>
            <param name="context">The context.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignedVariable">
            <summary>
            The variable from assignment
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignedVariable.#ctor(DatabaseSchemaReader.DataSchema.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignedVariable"/> class.
            </summary>
            <param name="sqlType">SQL type of the variable.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignedVariable.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition">
            <summary>
            The assignment from expression condition
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition.#ctor(Slp.Evi.Storage.Relational.Query.ICalculusVariable,Slp.Evi.Storage.Relational.Query.IExpression)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/> class.
            </summary>
            <param name="variable">The variable.</param>
            <param name="expression">The expression.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition.Variable">
            <summary>
            Gets the variable.
            </summary>
            <value>The variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition.Expression">
            <summary>
            Gets the expression.
            </summary>
            <value>The expression.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.IAssignmentConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.IAssignmentConditionVisitor">
            <summary>
            Visitor for assignment conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.IAssignmentConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="assignmentFromExpressionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition">
            <summary>
            The always false condition
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition">
            <summary>
            The always true condition
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition">
            <summary>
            The disjunction of conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.IFilterCondition})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/> class.
            </summary>
            <param name="conditions">The inner conditions.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition.InnerConditions">
            <summary>
            Gets the inner conditions.
            </summary>
            <value>The inner conditions.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition">
            <summary>
            The disjunction of conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.IFilterCondition})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/> class.
            </summary>
            <param name="conditions">The inner conditions.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition.InnerConditions">
            <summary>
            Gets the inner conditions.
            </summary>
            <value>The inner conditions.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition">
            <summary>
            The equal expression condition
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition.LeftOperand">
            <summary>
            Gets the left operand.
            </summary>
            <value>The left operand.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition.RightOperand">
            <summary>
            Gets the right operand.
            </summary>
            <value>The right operand.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition.#ctor(Slp.Evi.Storage.Relational.Query.IExpression,Slp.Evi.Storage.Relational.Query.IExpression)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/> class.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition">
            <summary>
            Class representing condition: equal for two <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusVariable"/>
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition.LeftVariable">
            <summary>
            Gets the left variable.
            </summary>
            <value>The left variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition.RightVariable">
            <summary>
            Gets the right variable.
            </summary>
            <value>The right variable.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition.#ctor(Slp.Evi.Storage.Relational.Query.ICalculusVariable,Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/> class.
            </summary>
            <param name="leftVariable">The left variable.</param>
            <param name="rightVariable">The right variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor">
            <summary>
            Visitor for filter conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="alwaysFalseCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="alwaysTrueCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="conjunctionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="disjunctionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="equalExpressionCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="equalVariablesCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="isNullCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="negationCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition">
            <summary>
            The  IS  NULL Condition.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition.#ctor(Slp.Evi.Storage.Relational.Query.ICalculusVariable)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/> class.
            </summary>
            <param name="calculusVariable">The calculus variable.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition.Variable">
            <summary>
            Gets the variable.
            </summary>
            <value>The variable.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition">
            <summary>
            Class NegationCondition.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition.#ctor(Slp.Evi.Storage.Relational.Query.IFilterCondition)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/> class.
            </summary>
            <param name="condition">The inner condition.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition.InnerCondition">
            <summary>
            Gets the inner condition.
            </summary>
            <value>The inner condition.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor">
            <summary>
            Visitor for source conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="tupleFromSourceCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="unionedSourcesCondition">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition">
            <summary>
            Class representing condition: assigning a tuple from a source
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition.CalculusVariables">
            <summary>
            Gets the calculus variables.
            </summary>
            <value>The calculus variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition.Source">
            <summary>
            Gets the source.
            </summary>
            <value>The source.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ICalculusVariable},Slp.Evi.Storage.Relational.Query.ICalculusSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/> class.
            </summary>
            <param name="calculusVariables">The calculus variables.</param>
            <param name="source">The source.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition">
            <summary>
            The source condition representing union
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition.#ctor(Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ICalculusVariable},System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ICalculusSource})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/> class.
            </summary>
            <param name="caseVariable">The case variable.</param>
            <param name="variables">The variables.</param>
            <param name="sources">The sources.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition.CalculusVariables">
            <summary>
            Gets the calculus variables.
            </summary>
            <value>The calculus variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition.Sources">
            <summary>
            Gets the source.
            </summary>
            <value>The source.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition.CaseVariable">
            <summary>
            Gets the case variable.
            </summary>
            <value>The case variable.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition.Accept(Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Conditions.IConditionVisitor">
            <summary>
            Visitor for conditions
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder">
            <summary>
            The switch value binder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.#ctor(System.String,Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder"/> class.
            </summary>
            <param name="variableName">Name of the variable.</param>
            <param name="caseVariable">The case variable.</param>
            <param name="cases">The cases.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Cases">
            <summary>
            Gets the cases.
            </summary>
            <value>The cases.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Accept(Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.LoadNode(VDS.RDF.INodeFactory,Slp.Evi.Storage.Database.IQueryResultRow,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Loads the node.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="rowData">The row data.</param>
            <param name="context">The context.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.CaseVariable">
            <summary>
            Gets the case variable.
            </summary>
            <value>The case variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.VariableName">
            <summary>
            Gets the name of the variable.
            </summary>
            <value>The name of the variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.NeededCalculusVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.ReferencedVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
            <remarks>May contain duplicate values</remarks>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case">
            <summary>
            Value binder case
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case.#ctor(System.Int32,Slp.Evi.Storage.Relational.Query.IValueBinder)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case"/> class.
            </summary>
            <param name="caseValue">The case value.</param>
            <param name="valueBinder">The value binder.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case.CaseValue">
            <summary>
            Gets the case value.
            </summary>
            <value>The case value.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder.Case.ValueBinder">
            <summary>
            Gets the value binder.
            </summary>
            <value>The value binder.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder">
            <summary>
            COALESCE value binder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder._valueBinders">
            <summary>
            The coalesced value binders
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.#ctor(System.String,Slp.Evi.Storage.Relational.Query.IValueBinder[])">
            <summary>
            
            </summary>
            <param name="variableName"></param>
            <param name="valueBinders"></param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.NeededCalculusVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.VariableName">
            <summary>
            Gets the name of the variable.
            </summary>
            <value>The name of the variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.ValueBinders">
            <summary>
            The coalesced value binders
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.Accept(Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder.LoadNode(VDS.RDF.INodeFactory,Slp.Evi.Storage.Database.IQueryResultRow,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Loads the node.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="rowData">The row data.</param>
            <param name="context">The context.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder">
            <summary>
            Representation of the base value binder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder._variables">
            <summary>
            The needed variables
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder._loadNodeFunc">
            <summary>
            The load node function
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.#ctor(System.String,TCode.r2rml4net.Mapping.ITermMap,Slp.Evi.Storage.Relational.Query.ISqlCalculusSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder"/> class.
            </summary>
            <param name="variableName">Name of the variable.</param>
            <param name="termMap">The term map.</param>
            <param name="source">The source.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.#ctor(Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder,System.Func{Slp.Evi.Storage.Relational.Query.ICalculusVariable,Slp.Evi.Storage.Relational.Query.ICalculusVariable})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder"/> class by copying another <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder"/>
            while replacing some of its columns
            </summary>
            <param name="baseValueBinder">The other base value binder.</param>
            <param name="calculusVariableSelection">The calculus variable selection function.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.TermMap">
            <summary>
            Gets the term map.
            </summary>
            <value>The term map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.VariableName">
            <summary>
            Gets the name of the variable.
            </summary>
            <value>The name of the variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.NeededCalculusVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.TemplateParts">
            <summary>
            Gets the template parts.
            </summary>
            <value>The template parts.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GetCalculusVariable(System.String)">
            <summary>
            Gets the calculus variable.
            </summary>
            <param name="columnName">Name of the column.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.Accept(Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GetVariable(System.String)">
            <summary>
            Gets the calculus variable.
            </summary>
            <param name="columnName">The column name.</param>
            <exception cref="T:System.Exception">Cannot get variable that is not requested for evaluation</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.LoadNode(VDS.RDF.INodeFactory,Slp.Evi.Storage.Database.IQueryResultRow,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Loads the node.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="rowData">The row data.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateLoadNodeFunc(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the load node function.
            </summary>
            <param name="queryContext">The query context</param>
            <returns>Generated function.</returns>
            <exception cref="T:System.Exception">Term map must be either constant, column or template valued</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateLoadNodeFuncFromTemplate(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the load node function from template.
            </summary>
            <param name="queryContext">The query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateReplaceColumnReferencesFunc(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the replace column references function.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="row">The row.</param>
            <param name="context">The context.</param>
            <param name="escape">if set to <c>true</c> the value should be escaped.</param>
            <param name="queryContext">The query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateReplaceColumnReferenceFunc(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart,Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Boolean,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the replace column reference function.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="row">The row.</param>
            <param name="context">The context.</param>
            <param name="part">The part.</param>
            <param name="column">The column.</param>
            <param name="escape">if set to <c>true</c> the value should be escaped.</param>
            <param name="queryContext">The query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateLoadNodeFuncFromConstant">
            <summary>
            Generates the load node function from constant.
            </summary>
            <exception cref="T:System.Exception">
            Object map's value must be IRI or literal.
            or
            Constant must be uri valued or an object map
            </exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateTermForValueFunc(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Generates the term for value function.
            </summary>
            <param name="factory">The factory.</param>
            <param name="value">The value.</param>
            <param name="context">The query context.</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateBlankNodeForValueFunc(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Generates the blank node for value function.
            </summary>
            <param name="factory">The factory.</param>
            <param name="value">The value.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateTermForLiteralFunc(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Generates the term for literal function.
            </summary>
            <param name="factory">The factory.</param>
            <param name="value">The value.</param>
            <param name="context">The query context.</param>
            <exception cref="T:System.Exception">
            Term map cannot be of term type literal
            or
            Literal term map cannot have both language tag and datatype set
            </exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateUriTermForValue(System.String,VDS.RDF.INodeFactory,Slp.Evi.Storage.Query.QueryContext,System.Uri)">
            <summary>
            Generates the URI term for value.
            </summary>
            <param name="value">The value.</param>
            <param name="factory">The factory.</param>
            <param name="context">The context.</param>
            <param name="baseUri">The base URI.</param>
            <exception cref="T:System.Exception">
            Now the uri must be absolute
            or
            </exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.ConstructAbsoluteUri(VDS.RDF.INodeFactory,System.String,System.Uri,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Constructs the absolute URI.
            </summary>
            <param name="factory">The factory.</param>
            <param name="relativePart">The relative part.</param>
            <param name="baseUri">The base URI.</param>
            <param name="context">The context.</param>
            <returns>Uri.</returns>
            <exception cref="T:System.Exception">The relative IRI cannot contain any . or .. parts</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.AssertNoIllegalCharacters(System.Uri)">
            <summary>
            Asserts the no illegal characters.
            </summary>
            <param name="value">The value.</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder.GenerateLoadNodeFuncFromColumn(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Generates the load node function from column.
            </summary>
            <param name="queryContext">The query context</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder">
            <summary>
            The empty value binder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder"/> class.
            </summary>
            <param name="variableName">Name of the variable.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder.LoadNode(VDS.RDF.INodeFactory,Slp.Evi.Storage.Database.IQueryResultRow,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Loads the node.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="rowData">The row data.</param>
            <param name="context">The context.</param>
            <returns>INode.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder.VariableName">
            <summary>
            Gets the name of the variable.
            </summary>
            <value>The name of the variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder.NeededCalculusVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder.Accept(Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor">
            <summary>
            Visitor for value binders
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder"/>
            </summary>
            <param name="baseValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.EmptyValueBinder"/>
            </summary>
            <param name="emptyValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.CoalesceValueBinder"/>
            </summary>
            <param name="coalesceValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.IValueBinderVisitor.Visit(Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.SwitchValueBinder"/>
            </summary>
            <param name="switchValueBinder">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor">
            <summary>
            Template processor
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TemplateReplaceRegex">
            <summary>
            The template replace regex
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.GetColumnsFromTemplate(System.String)">
            <summary>
            Gets the columns from template.
            </summary>
            <param name="template">The template.</param>
            <returns>Columns used in template.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ParseTemplate(System.String)">
            <summary>
            Parses the template.
            </summary>
            <param name="template">The template.</param>
            <returns>The template parts.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart">
            <summary>
            Template column part
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart"/> class.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart.Column">
            <summary>
            Gets the column.
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart.IsColumn">
            <summary>
            Gets a value indicating whether this instance is column.
            </summary>
            <value><c>true</c> if this instance is column; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart.IsText">
            <summary>
            Gets a value indicating whether this instance is text.
            </summary>
            <value><c>true</c> if this instance is text; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.ColumnTemplatePart.Text">
            <summary>
            Gets the text.
            </summary>
            <value>The text.</value>
            <exception cref="T:System.Exception">Asked for text on ColumnTemplatePart</exception>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart">
            <summary>
            Template text part
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart"/> class.
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart.Text">
            <summary>
            Gets the text.
            </summary>
            <value>The text.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart.IsColumn">
            <summary>
            Gets a value indicating whether this instance is column.
            </summary>
            <value><c>true</c> if this instance is column; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart.IsText">
            <summary>
            Gets a value indicating whether this instance is text.
            </summary>
            <value><c>true</c> if this instance is text; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.TemplateProcessor.TextTemplatePart.Column">
            <summary>
            Gets the column.
            </summary>
            <value>The column.</value>
            <exception cref="T:System.Exception">Asked for column on TextTemplatePart</exception>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart">
            <summary>
            Template part
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart.IsColumn">
            <summary>
            Gets a value indicating whether this instance is column.
            </summary>
            <value><c>true</c> if this instance is column; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart.IsText">
            <summary>
            Gets a value indicating whether this instance is text.
            </summary>
            <value><c>true</c> if this instance is text; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart.Column">
            <summary>
            Gets the column.
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ValueBinders.ITemplatePart.Text">
            <summary>
            Gets the text.
            </summary>
            <value>The text.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression">
            <summary>
            Column expression
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression.CalculusVariable">
            <summary>
            Gets the calculus variable.
            </summary>
            <value>The calculus variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression.IsUri">
            <summary>
            Gets a value indicating whether this instance is URI.
            </summary>
            <value><c>true</c> if this instance is URI; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression.#ctor(Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.ICalculusVariable,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/> class.
            </summary>
            <param name="context">The context.</param>
            <param name="calculusVariable">The calculus variable.</param>
            <param name="isUri">if set to <c>true</c> [is URI].</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression.Accept(Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression">
            <summary>
            The concatenation expression
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression._expressions">
            <summary>
            The concatenated expressions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression.#ctor(System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IExpression},DatabaseSchemaReader.DataSchema.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/> class.
            </summary>
            <param name="innerExpressions">The inner expressions.</param>
            <param name="sqlTypeForString">The SQL type for string.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression.InnerExpressions">
            <summary>
            The concatenated expressions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression.Accept(Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression">
            <summary>
            Class ConstantExpression.
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression._context">
            <summary>
            The context
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.SqlString">
            <summary>
            Gets the SQL string.
            </summary>
            <value>The SQL string.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.#ctor(System.Uri,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/> class.
            </summary>
            <param name="uri">The URI.</param>
            <param name="context">Query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.#ctor(System.String,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/> class.
            </summary>
            <param name="text">The text.</param>
            /// <param name="context">Query context</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.#ctor(System.Int32,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/> class.
            </summary>
            <param name="number">The number.</param>
            /// <param name="context">Query context</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression.Accept(Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor">
            <summary>
            The expression visitor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="columnExpression">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="concatenationExpression">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="constantExpression">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.IExpression">
            <summary>
            The relational expression
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.IExpression.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ICalculusSource">
            <summary>
            Calculus source
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ICalculusSource.Variables">
            <summary>
            Gets the provided variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ISqlCalculusSource">
            <summary>
            SQL Calculus source (representing directly some SQL table or query)
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.ISqlCalculusSource.GetVariable(System.String)">
            <summary>
            Gets the variable.
            </summary>
            <param name="name">The SQL name.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel">
            <summary>
            Model representing calculus representation of a query
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel._sourceConditions">
            <summary>
            The source conditions
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel._filterConditions">
            <summary>
            The filter conditions
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel._assignmentConditions">
            <summary>
            The assignment conditions
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ICalculusVariable},System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.ICondition})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/> class.
            </summary>
            <param name="variables">The variables.</param>
            <param name="conditions">The conditions.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.Variables">
            <summary>
            Gets the variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.SourceConditions">
            <summary>
            Gets the source conditions.
            </summary>
            <value>The source conditions.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.FilterConditions">
            <summary>
            Gets the filter conditions.
            </summary>
            <value>The filter conditions.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.AssignmentConditions">
            <summary>
            Gets the assignment conditions.
            </summary>
            <value>The assignment conditions.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel.Accept(Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor">
            <summary>
            Visitor for <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor.Visit(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="calculusModel">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor.Visit(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/>
            </summary>
            <param name="sqlTable">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn">
            <summary>
            The SQL column
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn.Table">
            <summary>
            Gets the table.
            </summary>
            <value>The table.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn.#ctor(System.String,Slp.Evi.Storage.Relational.Query.Sources.SqlTable,DatabaseSchemaReader.DataSchema.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn" /> class.
            </summary>
            <param name="name">The name.</param>
            <param name="table">The SQL table</param>
            <param name="sqlType">The SQL type of the column.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.SqlColumn.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable">
            <summary>
            SQL table representation
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.SqlTable.Variables">
            <summary>
            Gets the provided variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.Sources.SqlTable.TableName">
            <summary>
            Gets the name of the table.
            </summary>
            <value>The name of the table.</value>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Sources.SqlTable._tableInfo">
            <summary>
            The database schema information
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.SqlTable.#ctor(DatabaseSchemaReader.DataSchema.DatabaseTable)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/> class.
            </summary>
            <param name="tableInfo">The table information.</param>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Query.Sources.SqlTable._variables">
            <summary>
            The variables
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.SqlTable.GetVariable(System.String)">
            <summary>
            Gets the variable.
            </summary>
            <param name="name">The SQL name.</param>
            <returns>ICalculusVariable.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.Sources.SqlTable.Accept(Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ICondition">
            <summary>
            Condition representation
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ISourceCondition">
            <summary>
            Source condition
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ISourceCondition.CalculusVariables">
            <summary>
            Gets the calculus variables.
            </summary>
            <value>The calculus variables.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.IAssignmentCondition">
            <summary>
            Assignment condition
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.IFilterCondition">
            <summary>
            Filter condition
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.ICalculusVariable">
            <summary>
            Variable representation
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.ICalculusVariable.SqlType">
            <summary>
            The SQL type of the expression.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.RelationalQuery">
            <summary>
            Relational query
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.RelationalQuery.#ctor(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.IValueBinder})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Query.RelationalQuery"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="valueBinders">The value binders.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.RelationalQuery.Model">
            <summary>
            Gets the model.
            </summary>
            <value>The model.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.RelationalQuery.ValueBinders">
            <summary>
            Gets the value binders.
            </summary>
            <value>The value binders.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Query.IValueBinder">
            <summary>
            Value binder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Query.IValueBinder.LoadNode(VDS.RDF.INodeFactory,Slp.Evi.Storage.Database.IQueryResultRow,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Loads the node.
            </summary>
            <param name="nodeFactory">The node factory.</param>
            <param name="rowData">The row data.</param>
            <param name="context">The context.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.IValueBinder.VariableName">
            <summary>
            Gets the name of the variable.
            </summary>
            <value>The name of the variable.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Relational.Query.IValueBinder.NeededCalculusVariables">
            <summary>
            Gets the needed calculus variables to calculate the value.
            </summary>
            <value>The needed calculus variables.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1">
            <summary>
            The base class for relational optimizers
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseRelationalOptimizerImplementation`1.Transform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,Slp.Evi.Storage.Relational.Optimization.Optimizers.BaseRelationalOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IFilterConditionVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
            <typeparam name="T1">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" /></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.TransformFilterCondition(Slp.Evi.Storage.Relational.Query.IFilterCondition,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Relational.Query.IFilterCondition" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.CommonShouldTransform(Slp.Evi.Storage.Relational.Query.IFilterCondition,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.CommonPostTransform(`1,Slp.Evi.Storage.Relational.Query.IFilterCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.CommonFallbackTransform(Slp.Evi.Storage.Relational.Query.IFilterCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseFilterConditionTransformerG`3.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.IAssignmentConditionVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
            <typeparam name="T1">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ISourceCondition" /></typeparam>
            <typeparam name="T2">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.IFilterCondition" /></typeparam>
            <typeparam name="T3">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" /></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.TransformAssignmentCondition(Slp.Evi.Storage.Relational.Query.IAssignmentCondition,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Relational.Query.IAssignmentCondition" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.CommonShouldTransform(Slp.Evi.Storage.Relational.Query.IAssignmentCondition,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.CommonPostTransform(`1,Slp.Evi.Storage.Relational.Query.IAssignmentCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.CommonFallbackTransform(Slp.Evi.Storage.Relational.Query.IAssignmentCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseAssignmentConditionTransformerG`5.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.ISourceConditionVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
            <typeparam name="T1">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.IFilterCondition" /></typeparam>
            <typeparam name="T2">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" /></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.TransformSourceCondition(Slp.Evi.Storage.Relational.Query.ISourceCondition,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Relational.Query.ISourceCondition" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.CommonShouldTransform(Slp.Evi.Storage.Relational.Query.ISourceCondition,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.CommonPostTransform(`1,Slp.Evi.Storage.Relational.Query.ISourceCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.CommonFallbackTransform(Slp.Evi.Storage.Relational.Query.ISourceCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.Visit(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.ProcessVisit(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.ShouldTransform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceConditionTransformerG`4.FallbackTransform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.IExpressionVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
            <typeparam name="T1">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.IAssignmentCondition" /></typeparam>
            <typeparam name="T2">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ISourceCondition" /></typeparam>
            <typeparam name="T3">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.IFilterCondition" /></typeparam>
            <typeparam name="T4">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" /></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.TransformExpression(Slp.Evi.Storage.Relational.Query.IExpression,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Relational.Query.IExpression" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.CommonShouldTransform(Slp.Evi.Storage.Relational.Query.IExpression,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.CommonPostTransform(`1,Slp.Evi.Storage.Relational.Query.IExpression,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.CommonFallbackTransform(Slp.Evi.Storage.Relational.Query.IExpression,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ProcessVisit(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ShouldTransform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.FallbackTransform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ProcessVisit(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ShouldTransform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.FallbackTransform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Visit(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ProcessVisit(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.ShouldTransform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseExpressionTransformerG`6.FallbackTransform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.ICalculusSourceVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.TransformCalculusSource(Slp.Evi.Storage.Relational.Query.ICalculusSource,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.CommonShouldTransform(Slp.Evi.Storage.Relational.Query.ICalculusSource,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.CommonPostTransform(`1,Slp.Evi.Storage.Relational.Query.ICalculusSource,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.CommonFallbackTransform(Slp.Evi.Storage.Relational.Query.ICalculusSource,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.Visit(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.ProcessVisit(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.ShouldTransform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.FallbackTransform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.Visit(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.ProcessVisit(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.Transform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.ShouldTransform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.PostTransform(`1,Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.CodeGeneration.BaseSourceTransformerG`2.FallbackTransform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1">
            <summary>
            Base transformer for <see cref="T:Slp.Evi.Storage.Relational.Query.ICalculusSource" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Sources.CalculusModel,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.CalculusModel" />
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Sources.SqlTable,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Sources.SqlTable" />
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysFalseCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.AlwaysTrueCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.ConjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.DisjunctionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.EqualVariablesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.IsNullCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Filter.NegationCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.TupleFromSourceCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Source.UnionedSourcesCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ColumnExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConcatenationExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Expressions.ConstantExpression"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Utils.BaseRelationalTransformer`1.Transform(Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Relational.Query.Conditions.Assignment.AssignmentFromExpressionCondition"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Builder.ConditionBuilder">
            <summary>
            The conditions builder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Builder.ConditionBuilder._expressionBuilder">
            <summary>
            The expression builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.#ctor(Slp.Evi.Storage.Relational.Builder.ExpressionBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Builder.ConditionBuilder"/> class.
            </summary>
            <param name="expressionBuilder">The expression builder.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateEqualsConditions(VDS.RDF.INode,Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the equals conditions.
            </summary>
            <param name="node">The node.</param>
            <param name="valueBinder">The value binder.</param>
            <param name="context">The context.</param>
            <returns>IEnumerable&lt;ICondition&gt;.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateIsBoundConditions(Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the is not null conditions.
            </summary>
            <param name="valueBinder">The value binder.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateDisjunctionConditions(Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.IFilterCondition[])">
            <summary>
            Creates the disjunction of the conditions
            </summary>
            <param name="context">The query context</param>
            <param name="conditions">The conditions, conjunction of every array member taken as the disjunction parameter</param>
            <returns></returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateConjunctionCondition(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Relational.Query.IFilterCondition},Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the conjunction of the conditions.
            </summary>
            <param name="conditions">The conditions.</param>
            <param name="context">The query context.</param>
            <returns></returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateNegationConditions(Slp.Evi.Storage.Relational.Query.IFilterCondition,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Create negation conditions
            </summary>
            <param name="condition">The conditions</param>
            <param name="context">The query context.</param>
            <returns>The negation of the conditions.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateEqualsConditions(Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the equals conditions.
            </summary>
            <param name="firstValueBinder">The first value binder.</param>
            <param name="secondValueBinder">The second value binder.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ConditionBuilder.CreateJoinEqualCondition(Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Relational.Query.IValueBinder,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Creates the join equal condition
            </summary>
            <param name="valueBinder">First value binder</param>
            <param name="otherValueBinder">Other value binder</param>
            <param name="context">The query context</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Builder.ExpressionBuilder">
            <summary>
            The expression builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ExpressionBuilder.CreateExpression(Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.IValueBinder)">
            <summary>
            Creates the expression.
            </summary>
            <param name="context">The context.</param>
            <param name="valueBinder">The value binder.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ExpressionBuilder.CreateBaseValueBinderExpression(Slp.Evi.Storage.Query.QueryContext,Slp.Evi.Storage.Relational.Query.ValueBinders.BaseValueBinder)">
            <summary>
            Creates the base value binder expression.
            </summary>
            <param name="context">The context.</param>
            <param name="valueBinder">The value binder.</param>
            <returns>IExpression.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ExpressionBuilder.CreateExpression(Slp.Evi.Storage.Query.QueryContext,VDS.RDF.INode)">
            <summary>
            Creates the expression.
            </summary>
            <param name="context">The context.</param>
            <param name="node">The node.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.ExpressionBuilder.CreateLiteralExpression(Slp.Evi.Storage.Query.QueryContext,VDS.RDF.LiteralNode)">
            <summary>
            Creates the literal expression.
            </summary>
            <param name="context">The context.</param>
            <param name="node">The node.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Relational.Builder.RelationalBuilder">
            <summary>
            Relational builder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Builder.RelationalBuilder._conditionBuilder">
            <summary>
            The condition builder
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Relational.Builder.RelationalBuilder._expressionBuilder">
            <summary>
            The expression builder
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Relational.Builder.RelationalBuilder"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Process(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the specified algebra.
            </summary>
            <param name="algebra">The algebra.</param>
            <param name="context">The context.</param>
            <returns>RelationalQuery.</returns>
            <exception cref="T:System.ArgumentException">Unexpected type;algebra</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern" />
            </summary>
            <param name="emptyPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern" />
            </summary>
            <param name="filterPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern" />
            </summary>
            <param name="notMatchingPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern" />
            </summary>
            <param name="graphPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern" />
            </summary>
            <param name="joinPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern" />
            </summary>
            <param name="leftJoinPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern" />
            </summary>
            <param name="minusPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern" />
            </summary>
            <param name="triplePattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
            <exception cref="T:System.InvalidOperationException">The triple pattern should not be present when transforming to relational form.</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern" />
            </summary>
            <param name="unionPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern" />
            </summary>
            <param name="restrictedTriplePattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.Visit(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier" />
            </summary>
            <param name="selectModifier">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternSource(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource@,Slp.Evi.Storage.Relational.Query.ISqlCalculusSource@,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern source.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="conditions">The conditions.</param>
            <param name="source">The source.</param>
            <param name="refSource">The reference source.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.GetTripleMapSource(TCode.r2rml4net.Mapping.ITriplesMap,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Gets the triple map source.
            </summary>
            <param name="tripleMap">The triple map.</param>
            <param name="context">The context.</param>
            <returns>ISqlCalculusSource.</returns>
            <exception cref="T:System.ArgumentException">Unknown source;tripleMap</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternPredicate(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern predicate.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternItem(VDS.RDF.Query.Patterns.PatternItem,TCode.r2rml4net.Mapping.ITermMap,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern item.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="termMap">The term map</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternCondition(VDS.RDF.INode,TCode.r2rml4net.Mapping.ITermMap,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern condition.
            </summary>
            <param name="node">The node.</param>
            <param name="termMap">The term map.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternVariable(System.String,TCode.r2rml4net.Mapping.ITermMap,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern variable.
            </summary>
            <param name="variableName">Name of the variable.</param>
            <param name="termMap">The term map.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternSubject(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern subject.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternObject(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern object.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Relational.Builder.RelationalBuilder.ProcessTriplePatternRefObject(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.ICondition},System.Collections.Generic.List{Slp.Evi.Storage.Relational.Query.IValueBinder},Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Relational.Query.ISqlCalculusSource,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the triple pattern reference object.
            </summary>
            <param name="triplePattern">The triple pattern.</param>
            <param name="conditions">The conditions.</param>
            <param name="valueBinders">The value binders.</param>
            <param name="source">The source.</param>
            <param name="refSource">The reference source.</param>
            <param name="context">The query context.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.IGraphPattern">
            <summary>
            Base interface for all patterns
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.IModifier">
            <summary>
            Base interface for SPARQL result modifiers
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery">
            <summary>
            Base interface for all SPARQL queries
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.IModifierVisitor">
            <summary>
            Visitor interface of SPARQL result modifiers
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Modifiers.IModifierVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier"/>
            </summary>
            <param name="selectModifier">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier">
            <summary>
            Select modifier
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier.#ctor(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier"/> class.
            </summary>
            <param name="innerQuery">The inner query.</param>
            <param name="sparqlVariables">The sparql variables.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier.InnerQuery">
            <summary>
            Gets the inner query.
            </summary>
            <value>The inner query.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier.Accept(Slp.Evi.Storage.Sparql.Algebra.Modifiers.IModifierVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern">
            <summary>
            Empty pattern
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern">
            <summary>
            Filter pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern.#ctor(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern"/> class.
            </summary>
            <param name="innerPattern">The inner pattern.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern.InnerPattern">
            <summary>
            Gets the inner pattern.
            </summary>
            <value>The inner pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern">
            <summary>
            Graph pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern.#ctor(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern"/> class.
            </summary>
            <param name="innerPattern">The inner pattern.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern.InnerPattern">
            <summary>
            Gets the inner pattern.
            </summary>
            <value>The inner pattern.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor">
            <summary>
            Visitor interface for SPARQL patterns
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern"/>
            </summary>
            <param name="emptyPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern"/>
            </summary>
            <param name="filterPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern"/>
            </summary>
            <param name="notMatchingPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern"/>
            </summary>
            <param name="graphPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="joinPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern"/>
            </summary>
            <param name="leftJoinPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern"/>
            </summary>
            <param name="minusPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/>
            </summary>
            <param name="triplePattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/>
            </summary>
            <param name="unionPattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/>
            </summary>
            <param name="restrictedTriplePattern">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern">
            <summary>
            Join pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Sparql.Algebra.IGraphPattern})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/> class.
            </summary>
            <param name="joinedGraphPatterns">The joined graph patterns.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern.JoinedGraphPatterns">
            <summary>
            Gets the joined graph patterns.
            </summary>
            <value>The joined graph patterns.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern">
            <summary>
            Left join
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern.#ctor(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,Slp.Evi.Storage.Sparql.Algebra.IGraphPattern)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern"/> class.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern.RightOperand">
            <summary>
            Gets the right operand.
            </summary>
            <value>The right operand.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern.LeftOperand">
            <summary>
            Gets the left operand.
            </summary>
            <value>The left operand.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern">
            <summary>
            Minus pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern.#ctor(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,Slp.Evi.Storage.Sparql.Algebra.IGraphPattern)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern"/> class.
            </summary>
            <param name="leftOperand">The left operand.</param>
            <param name="rightOperand">The right operand.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern.RightOperand">
            <summary>
            Gets the right operand.
            </summary>
            <value>The right operand.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern.LeftOperand">
            <summary>
            Gets the left operand.
            </summary>
            <value>The left operand.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern">
            <summary>
            Pattern that is not matching anything
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern">
            <summary>
            Triple pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/> class.
            </summary>
            <param name="subjectPattern">The subject pattern.</param>
            <param name="predicatePattern">The predicate pattern.</param>
            <param name="objectPattern">The object pattern.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.AddToVariables(VDS.RDF.Query.Patterns.PatternItem,System.Collections.Generic.List{System.String})">
            <summary>
            Adds to variables list.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="variables">The variables list.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.SubjectPattern">
            <summary>
            Gets the subject pattern.
            </summary>
            <value>The subject pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.PredicatePattern">
            <summary>
            Gets the predicate pattern.
            </summary>
            <value>The predicate pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern.ObjectPattern">
            <summary>
            Gets the object pattern.
            </summary>
            <value>The object pattern.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern">
            <summary>
            Triple pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,TCode.r2rml4net.Mapping.ITriplesMap,TCode.r2rml4net.Mapping.ISubjectMap,TCode.r2rml4net.Mapping.IPredicateMap,TCode.r2rml4net.Mapping.IObjectMap,TCode.r2rml4net.Mapping.IRefObjectMap,TCode.r2rml4net.Mapping.IGraphMap)">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/> class.
            </summary>
            <param name="subjectPattern">The subject pattern.</param>
            <param name="predicatePattern">The predicate pattern.</param>
            <param name="objectPattern">The object pattern.</param>
            <param name="tripleMap">The triple map.</param>
            <param name="subjectMap">The subject map.</param>
            <param name="predicateMap">The predicate map.</param>
            <param name="objectMap">The object map.</param>
            <param name="refObjectMap">The reference object map</param>
            <param name="graphMap">The graph map.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.GraphMap">
            <summary>
            Gets the graph map.
            </summary>
            <value>The graph map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.ObjectMap">
            <summary>
            Gets the object map.
            </summary>
            <value>The object map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.RefObjectMap">
            <summary>
            Gets the reference object map.
            </summary>
            <value>The reference object map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.PredicateMap">
            <summary>
            Gets the predicate map.
            </summary>
            <value>The predicate map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.SubjectMap">
            <summary>
            Gets or sets the subject map.
            </summary>
            <value>The subject map.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.TripleMap">
            <summary>
            Gets the triple map.
            </summary>
            <value>The triple map.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.AddToVariables(VDS.RDF.Query.Patterns.PatternItem,System.Collections.Generic.List{System.String})">
            <summary>
            Adds to variables list.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="variables">The variables list.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.SubjectPattern">
            <summary>
            Gets the subject pattern.
            </summary>
            <value>The subject pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.PredicatePattern">
            <summary>
            Gets the predicate pattern.
            </summary>
            <value>The predicate pattern.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern.ObjectPattern">
            <summary>
            Gets the object pattern.
            </summary>
            <value>The object pattern.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern">
            <summary>
            Union pattern
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern.#ctor(System.Collections.Generic.IEnumerable{Slp.Evi.Storage.Sparql.Algebra.IGraphPattern})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/> class.
            </summary>
            <param name="unionedGraphPatterns">The unioned graph patterns.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern.UnionedGraphPatterns">
            <summary>
            Gets the unioned graph patterns.
            </summary>
            <value>The unioned graph patterns.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern.Variables">
            <summary>
            Gets the SPARQL variables.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern.Accept(Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder">
            <summary>
            SPARQL algebra builder.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.Process(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the specified context.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
            <exception cref="T:System.Exception">Cannot handle unknown query type</exception>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.ProcessAsk(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the ask query.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.ProcessConstruct(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the construct query.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.ProcessDescribe(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the describe query.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.ProcessSelect(Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the select query.
            </summary>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Builder.SparqlBuilder.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Processes the algebra.
            </summary>
            <param name="originalAlgebra">The original algebra.</param>
            <param name="context">The query context.</param>
            <returns>The SPARQL query.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.ISparqlOptimizer">
            <summary>
            Interface for SPARQL optimization
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.ISparqlOptimizer.Optimize(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Optimizes the specified query.
            </summary>
            <param name="query">The query.</param>
            <param name="context">The context.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1">
            <summary>
            The base class for SPARQL optimization
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1._optimizerImplementation">
            <summary>
            The optimizer implementation
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.#ctor(Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1"/> class.
            </summary>
            <param name="optimizerImplementation">The optimizer implementation.</param>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.OptimizerImplementation">
            <summary>
            Gets the optimizer implementation.
            </summary>
            <value>The optimizer implementation.</value>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.OptimizationContext">
            <summary>
            The optimization context
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.OptimizationContext.Context">
            <summary>
            Gets or sets the query context.
            </summary>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.OptimizationContext.Data">
            <summary>
            Gets or sets the data.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.Optimize(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,Slp.Evi.Storage.Query.QueryContext)">
            <summary>
            Optimizes the specified query.
            </summary>
            <param name="query">The query.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.CreateInitialData">
            <summary>
            Creates the initial data.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer`1.CommonPostTransform(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,Slp.Evi.Storage.Sparql.Algebra.IModifier,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Postprocess for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The postprocessed transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer">
            <summary>
            The triple pattern optimization
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer"/> class.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation">
            <summary>
            The implementation class for <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer"/>
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation._templateProcessor">
            <summary>
            The template processor
            </summary>
        </member>
        <member name="F:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation._patternComparer">
            <summary>
            The pattern comparer
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.CanSubjectMatch(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Can the subject match the pattern?.
            </summary>
            <param name="toTransform">To transform.</param>
            <param name="data">The data.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.CanPredicateMatch(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Can the predicate match the pattern?.
            </summary>
            <param name="toTransform">To transform.</param>
            <param name="data">The data.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.CanObjectMatch(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Can the object match the pattern?.
            </summary>
            <param name="toTransform">To transform.</param>
            <param name="data">The data.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.CanMatch(VDS.RDF.INode,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the node can match the mapping.
            </summary>
            <param name="node">The match pattern node.</param>
            <param name="termMap">The mapping.</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.TriplePatternOptimizer.TriplePatternOptimizerImplementation.CanMatch(Slp.Evi.Storage.Common.Optimization.PatternMatching.Pattern,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the pattern can match the mapping.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="termMap">The term map.</param>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer">
            <summary>
            The union / join optimization
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer"/> class.
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation">
            <summary>
            The implementation class for <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer"/>
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.ProcessJoinChild(System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.IGraphPattern},System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern},Slp.Evi.Storage.Sparql.Algebra.IGraphPattern)">
            <summary>
            Processes children of the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="childPatterns">All child patterns of a type different from <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/> and <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/></param>
            <param name="childUnionPatterns">All child patterns of a type <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/></param>
            <param name="joinedGraphPattern">The child to be processed</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CreateCartesian(System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.IGraphPattern},System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern},Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Creates the Cartesian product
            </summary>
            <param name="childPatterns">All child patterns of a type different from <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/> and <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/></param>
            <param name="childUnionPatterns">All child patterns of a type <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/></param>
            <param name="data">The context</param>
            <returns></returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.ProcessCartesian(System.Collections.Generic.List{Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult},Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Processes the current Cartesian product
            </summary>
            <param name="currentCartesians">Current Cartesian products</param>
            <param name="childUnionPattern">The <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/> to process</param>
            <param name="data">The context</param>
            <returns></returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult">
            <summary>
            Cartesian result
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult"/> class.
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns>The cloned instance.</returns>
        </member>
        <member name="F:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult._variables">
            <summary>
            Gets the variables mappings.
            </summary>
            <value>The variables.</value>
        </member>
        <member name="P:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.Queries">
            <summary>
            Gets the queries.
            </summary>
            <value>The queries.</value>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.AddTriplePatternInfo(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern)">
            <summary>
            Adds the information from the passed <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/> to the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult"/>
            </summary>
            <param name="triplePattern">The passed <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/> to process</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.AddPatternInfo(VDS.RDF.Query.Patterns.PatternItem,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Adds the pattern information
            </summary>
            <param name="pattern">The pattern</param>
            <param name="termMap">The mapping for the pattern</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.AddVariableInfo(System.String,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Adds the information for the variable
            </summary>
            <param name="variableName">The variable name</param>
            <param name="termMap">The mapping for the variable</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.VerifyTriplePattern(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{System.Object}.OptimizationContext)">
            <summary>
            Verifies whether the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/> can be added to the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult"/>
            </summary>
            <param name="triplePattern">The passed <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/> to process</param>
            <param name="data">The context</param>
            <returns>Returns <c>true</c> if the <paramref name="triplePattern"/> can be added to the <see cref="T:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult"/>; <c>false</c> otherwise</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.VerifyPatternInfo(VDS.RDF.Query.Patterns.PatternItem,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Verifies the pattern information
            </summary>
            <param name="pattern">The pattern</param>
            <param name="termMap">The mapping for the pattern</param>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.VerifyVariableInfo(System.String,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Verifies the information for the variable
            </summary>
            <param name="variableName">The variable name</param>
            <param name="termMap">The mapping for the variable</param>
        </member>
        <member name="F:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult._templateProcessor">
            <summary>
            The template processor
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the first mapping can match the second mapping.
            </summary>
            <param name="first">The first mapping.</param>
            <param name="second">The second mapping.</param>
            <returns><c>true</c> if first mapping can match the second one; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanTemplateMatch(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the first template mapping can match the second mapping.
            </summary>
            <param name="first">The first template mapping.</param>
            <param name="second">The second mapping.</param>
            <returns><c>true</c> if first mapping can match the second one; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanColumnMatch(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the first column mapping can match the second mapping.
            </summary>
            <param name="first">The first column mapping.</param>
            <param name="second">The second mapping.</param>
            <returns><c>true</c> if first mapping can match the second one; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(System.String,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the first literal mapping can match the second mapping.
            </summary>
            <param name="literal">The literal mapping.</param>
            <param name="second">The second mapping.</param>
            <returns><c>true</c> if first mapping can match the second one; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(System.Uri,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the first URI mapping can match the second mapping.
            </summary>
            <param name="uri">The first URI mapping.</param>
            <param name="second">The second mapping.</param>
            <returns><c>true</c> if first mapping can match the second one; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(System.Uri,System.Uri)">
            <summary>
            Determines whether the URIs can match.
            </summary>
            <param name="firstUri">The first URI.</param>
            <param name="secondUri">The second URI.</param>
            <returns><c>true</c> if the URIs can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(System.String,System.String)">
            <summary>
            Determines whether the literals can match.
            </summary>
            <param name="firstLiteral">The first literal.</param>
            <param name="secondLiteral">The second literal.</param>
            <returns><c>true</c> if the literals can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatch(System.String,System.Uri)">
            <summary>
            Determines whether the literal can match uri.
            </summary>
            <param name="literal">The first literal.</param>
            <param name="uri">The second URI.</param>
            <returns><c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanTemplatesMatch(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the template mappings can match.
            </summary>
            <param name="firstTemplateTermMap">The first template mapping.</param>
            <param name="secondTemplateTermMap">The second template mapping.</param>
            <returns><c>true</c> if the template mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanTemplateMatchColumn(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the template mapping can match the column mapping.
            </summary>
            <param name="firstTemplateTermMap">The first template mapping.</param>
            <param name="secondColumnTermMap">The second column mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatchTemplate(System.String,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the literal can match the template mapping.
            </summary>
            <param name="literal">The literal.</param>
            <param name="templateTermMap">The template mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatchTemplate(System.Uri,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the URI can match the template mapping.
            </summary>
            <param name="uri">The URI.</param>
            <param name="templateTermMap">The template mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanColumnsMatch(TCode.r2rml4net.Mapping.ITermMap,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the column mappings can match.
            </summary>
            <param name="firstColumnTermMap">The first column mapping.</param>
            <param name="secondColumnTermMap">The second column mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatchColumn(System.String,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the literal can match the column mapping.
            </summary>
            <param name="literal">The literal.</param>
            <param name="columnTermMap">The column mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatchColumn(System.Uri,TCode.r2rml4net.Mapping.ITermMap)">
            <summary>
            Determines whether the URI can match the column mapping.
            </summary>
            <param name="uri">The URI.</param>
            <param name="columnTermMap">The column mapping.</param>
            <returns><c>true</c> if the mappings can match; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.CanMatchFunction``1(TCode.r2rml4net.Mapping.ITermMap,System.Func{System.Uri,``0},System.Func{System.String,``0},System.Func{TCode.r2rml4net.Mapping.ITermMap,``0},System.Func{TCode.r2rml4net.Mapping.ITermMap,``0})">
            <summary>
            The can match function.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="decider">The mapping chosen as decider which function will be used.</param>
            <param name="constantUriFunc">The constant URI function.</param>
            <param name="constantLiteralFunc">The constant literal function.</param>
            <param name="columnFunc">The column function.</param>
            <param name="templateFunc">The template function.</param>
            <exception cref="T:System.Exception">
            Object map must be an IRI or Literal
            or
            Constant value term must be uri valued or an object map
            or
            Term must be constant, column or template valued
            </exception>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.TemplateMatchCheck(System.String,System.String,System.Boolean)">
            <summary>
            Can the template match the value.
            </summary>
            <param name="template">The template.</param>
            <param name="value">The value.</param>
            <param name="isIri">if set to <c>true</c> the values are IRI.</param>
            <returns><c>true</c> if the template can match the value, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Optimization.Optimizers.UnionJoinOptimizer.UnionJoinOptimizerImplementation.CartesianResult.TemplatesMatchCheck(System.String,System.String,System.Boolean)">
            <summary>
            Can the templates match.
            </summary>
            <param name="firstTemplate">The first template.</param>
            <param name="secondTemplate">The second template.</param>
            <param name="isIri">if set to <c>true</c> the values are IRI.</param>
            <returns><c>true</c> if the templates can match, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1">
            <summary>
            Base class for SPARQL transformations
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.TransformSparqlQuery(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery" />.
            </summary>
            <param name="instance">The instance to tranform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.BaseSparqlTransformer`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.IGraphPatternVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
            <typeparam name="T1">Type of the transformation result when processing <see cref="T:Slp.Evi.Storage.Sparql.Algebra.IModifier" /></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.TransformGraphPattern(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.IGraphPattern" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.CommonShouldTransform(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.CommonPostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.CommonFallbackTransform(Slp.Evi.Storage.Sparql.Algebra.IGraphPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Visit(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseGraphPatternTransformerG`3.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2">
            <summary>
            Base generated transformer for <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.IModifierVisitor" />
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
            <typeparam name="TR">Type of the transformation result</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.TransformModifier(Slp.Evi.Storage.Sparql.Algebra.IModifier,`0)">
            <summary>
            Transforms the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.IModifier" />.
            </summary>
            <param name="instance">The instance to transform.</param>
            <param name="data">The passed data.</param>
            <returns>The transformed calculus source.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.CommonShouldTransform(Slp.Evi.Storage.Sparql.Algebra.IModifier,`0)">
            <summary>
            Decides whether we should use standard or fallback transformation for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should process standardly, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.CommonPostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.IModifier,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.CommonFallbackTransform(Slp.Evi.Storage.Sparql.Algebra.IModifier,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.Visit(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,System.Object)">
            <summary>
            Visits <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.ProcessVisit(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Processes the visit of <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier" />
            </summary>
            <param name="toVisit">The visited instance</param>
            <param name="data">The passed data</param>
            <returns>The returned data</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.Transform(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.ShouldTransform(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Pre-process for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed</param>
            <param name="data">The passed data</param>
            <returns><c>true</c> if transformation should continue, <c>false</c> the fallback should be used.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.PostTransform(`1,Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Post-process for the transformation.
            </summary>
            <param name="transformed">The transformation result.</param>
            <param name="toTransform">The transformed instance</param>
            <param name="data">The passed data.</param>
            <returns>The post-processed transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseModifierTransformerG`2.FallbackTransform(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,`0)">
            <summary>
            Fallback variant for the transformation.
            </summary>
            <param name="toTransform">Instance to be transformed.</param>
            <param name="data">The passed data.</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1">
            <summary>
            The base class for SPARQL optimizers
            </summary>
            <typeparam name="T">Type of parameter passed to process</typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.TransformSparqlQuery(Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.ISparqlQuery"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.EmptyPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.FilterPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.NotMatchingPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.GraphPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.JoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.LeftJoinPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.MinusPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.TriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.UnionPattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Patterns.RestrictedTriplePattern"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.CodeGeneration.BaseSparqlOptimizerImplementation`1.Transform(Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier,Slp.Evi.Storage.Sparql.Optimization.Optimizers.BaseSparqlOptimizer{`0}.OptimizationContext)">
            <summary>
            Process the <see cref="T:Slp.Evi.Storage.Sparql.Algebra.Modifiers.SelectModifier"/>
            </summary>
            <param name="toTransform">The instance to process</param>
            <param name="data">The passed data</param>
            <returns>The transformation result</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Sparql.Utils.FixesExtension">
            <summary>
            Fixes for SPARQL
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Sparql.Utils.FixesExtension.Node(VDS.RDF.Query.Expressions.Primary.ConstantTerm)">
            <summary>
            Gets the node for the specified term.
            </summary>
            <param name="term">The term.</param>
            <returns>The node.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Utils.IVisitable`1">
            <summary>
            Visitable object for visitor pattern
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Slp.Evi.Storage.Utils.IVisitable`1.Accept(`0,System.Object)">
            <summary>
            Accepts the specified visitor.
            </summary>
            <param name="visitor">The visitor.</param>
            <param name="data">The data.</param>
            <returns>The returned value from visitor.</returns>
        </member>
        <member name="T:Slp.Evi.Storage.Utils.IVisitor">
            <summary>
            The visitor for visitor pattern
            </summary>
        </member>
        <member name="T:Slp.Evi.Storage.Utils.UriExtensions">
            <summary>
            Extensions for Uri
            </summary>
        </member>
        <member name="M:Slp.Evi.Storage.Utils.UriExtensions.UriEquals(System.Uri,System.Uri)">
            <summary>
            Are the URIs equal.
            </summary>
            <param name="first">The first URI.</param>
            <param name="second">The second URI.</param>
            <returns><c>true</c> if the URIs are equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Slp.Evi.Storage.Utils.UriExtensions.ToCompleteUri(System.Uri)">
            <summary>
            Returns complete URI string (including fragment)
            </summary>
        </member>
    </members>
</doc>
